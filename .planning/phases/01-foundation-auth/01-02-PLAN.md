---
phase: 01-foundation-auth
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - backend/src/config/database.ts
  - backend/src/config/redis.ts
  - backend/src/config/jwt.ts
  - backend/src/models/User.ts
  - backend/src/middleware/auth.ts
  - backend/src/middleware/validate.ts
  - backend/src/routes/auth.ts
  - backend/src/controllers/authController.ts
  - backend/src/utils/tokenUtils.ts
  - backend/src/utils/validation.ts
  - backend/src/server.ts
  - backend/schema.sql
  - backend/package.json
autonomous: true

must_haves:
  truths:
    - "POST /auth/signup creates user and returns access token"
    - "POST /auth/login validates credentials and returns access token"
    - "POST /auth/logout invalidates tokens"
    - "POST /auth/refresh exchanges refresh cookie for new access token"
    - "Invalid credentials return 401 with clear error message"
  artifacts:
    - path: "backend/src/routes/auth.ts"
      provides: "Authentication API routes"
      exports: ["router"]
    - path: "backend/src/models/User.ts"
      provides: "User database operations"
      exports: ["User"]
    - path: "backend/src/middleware/auth.ts"
      provides: "JWT verification middleware"
      exports: ["authenticateToken"]
    - path: "backend/schema.sql"
      provides: "Database schema"
      contains: "CREATE TABLE users"
  key_links:
    - from: "backend/src/routes/auth.ts"
      to: "backend/src/controllers/authController.ts"
      via: "route handlers"
      pattern: "authController\\."
    - from: "backend/src/controllers/authController.ts"
      to: "backend/src/models/User.ts"
      via: "database queries"
      pattern: "User\\.(findByEmail|create)"
    - from: "backend/src/middleware/auth.ts"
      to: "backend/src/config/redis.ts"
      via: "token blacklist check"
      pattern: "redis\\.(exists|get)"
---

<objective>
Implement the complete backend authentication system with PostgreSQL user storage, Redis token management, and secure JWT-based auth endpoints.

Purpose: Provide server-side authentication infrastructure that handles signup, login, logout, and token refresh with proper security measures from RESEARCH.md (bcrypt cost 12, token blacklisting, input validation, HttpOnly cookies).
Output: Working auth API endpoints that can be tested with curl/Postman before frontend integration.
</objective>

<execution_context>
@C:\Users\Chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-auth/01-RESEARCH.md
@.planning/phases/01-foundation-auth/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure database, Redis, and JWT utilities</name>
  <files>
    backend/src/config/database.ts
    backend/src/config/redis.ts
    backend/src/config/jwt.ts
    backend/src/models/User.ts
    backend/src/utils/tokenUtils.ts
    backend/schema.sql
    backend/package.json
  </files>
  <action>
    Set up infrastructure layer:

    1. Add dependencies to package.json:
       - pg, redis, jsonwebtoken, bcrypt
       - @types/pg, @types/jsonwebtoken, @types/bcrypt as devDependencies

    2. Create src/config/database.ts:
       - PostgreSQL Pool from pg library
       - Connection from DATABASE_URL env var
       - Export pool for queries

    3. Create src/config/redis.ts:
       - Redis client from redis library
       - Connection from REDIS_URL env var
       - Connect on import, handle connection errors
       - Export redis client

    4. Create src/config/jwt.ts:
       - Export JWT_SECRET, JWT_REFRESH_SECRET from env
       - Export ACCESS_TOKEN_EXPIRY = '15m'
       - Export REFRESH_TOKEN_EXPIRY = '30d'
       - Export REFRESH_TOKEN_EXPIRY_SECONDS = 30 * 24 * 60 * 60

    5. Create src/models/User.ts:
       - Interface User { id: number; email: string; passwordHash: string; name: string; createdAt: Date; updatedAt: Date }
       - findByEmail(email: string): Promise<User | null>
       - findById(id: number): Promise<User | null>
       - create(data: { email: string; passwordHash: string; name: string }): Promise<User>
       - Use parameterized queries to prevent SQL injection

    6. Create src/utils/tokenUtils.ts:
       - generateAccessToken(user: { id: number; email: string }): string
       - generateRefreshToken(userId: number): string
       - verifyAccessToken(token: string): JwtPayload (with algorithms: ['HS256'])
       - verifyRefreshToken(token: string): JwtPayload (with algorithms: ['HS256'])
       - storeRefreshToken(userId: number, token: string): Promise<void> (Redis SET with TTL)
       - isRefreshTokenValid(userId: number, token: string): Promise<boolean> (Redis check)
       - blacklistToken(token: string, expirySeconds: number): Promise<void> (Redis blacklist)
       - isTokenBlacklisted(token: string): Promise<boolean> (Redis check)
       - revokeRefreshToken(userId: number, token: string): Promise<void> (Redis DEL)

    7. Create schema.sql:
       - CREATE TABLE users with id SERIAL PRIMARY KEY, email VARCHAR(255) UNIQUE NOT NULL, password_hash VARCHAR(255) NOT NULL, name VARCHAR(100) NOT NULL, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
       - Email format CHECK constraint
       - Index on email
       - Update timestamp trigger function
  </action>
  <verify>
    TypeScript compiles: cd backend && npx tsc --noEmit
    PostgreSQL schema runs: psql $DATABASE_URL -f schema.sql (manual verification)
    Redis connects: Server starts without redis connection errors
  </verify>
  <done>
    Database pool, Redis client, JWT utilities, and User model ready for auth endpoints
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement auth endpoints with validation and middleware</name>
  <files>
    backend/src/middleware/auth.ts
    backend/src/middleware/validate.ts
    backend/src/utils/validation.ts
    backend/src/controllers/authController.ts
    backend/src/routes/auth.ts
    backend/src/server.ts
  </files>
  <action>
    Implement authentication API:

    1. Create src/utils/validation.ts with express-validator schemas:
       - signupValidation: email (isEmail, normalizeEmail), password (min 8 chars, must contain uppercase, lowercase, number), name (trim, 2-50 chars, escape)
       - loginValidation: email (isEmail, normalizeEmail), password (notEmpty)

    2. Create src/middleware/validate.ts:
       - Export validate middleware that checks validationResult
       - Return 400 with { errors: [{ field, message }] } on validation failure
       - Call next() on success

    3. Create src/middleware/auth.ts:
       - Export authenticateToken middleware:
         - Extract token from Authorization: Bearer header
         - Return 401 if no token
         - Verify token with verifyAccessToken (catches TokenExpiredError, JsonWebTokenError)
         - Check if token is blacklisted via isTokenBlacklisted
         - Attach decoded user to req.user
         - Return 401 with specific error messages (Token expired, Token revoked, Invalid token)

    4. Create src/controllers/authController.ts:
       - signup: Check if email exists (409 if yes), hash password with bcrypt cost 12, create user, return 201 with { message, user: { id, email, name } }
       - login: Find user by email, verify password with bcrypt.compare, generate access + refresh tokens, store refresh in Redis, set refreshToken HttpOnly cookie (secure in prod, sameSite: strict, maxAge: 30 days), return { accessToken, user: { id, email, name } }
       - logout: Extract access token from header, refresh token from cookie, decode both to get expiry, blacklist both until expiry, delete refresh from Redis, clear cookie, return { message: "Logged out successfully" }
       - refresh: Get refreshToken from cookie, return 401 if missing, verify token, check blacklist, check Redis for valid refresh, generate new access token, return { accessToken, user }

    5. Create src/routes/auth.ts:
       - POST /signup with signupValidation, validate, authController.signup
       - POST /login with loginValidation, validate, authController.login
       - POST /logout with authenticateToken, authController.logout
       - POST /refresh with authController.refresh
       - Export router

    6. Update src/server.ts:
       - Import and use auth routes at /auth
       - Add express-validator to package.json

    Add express-validator to package.json dependencies.
  </action>
  <verify>
    Test with curl:
    1. Signup: curl -X POST http://localhost:3000/auth/signup -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"Password123","name":"Test User"}' returns 201
    2. Login: curl -X POST http://localhost:3000/auth/login -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"Password123"}' -c cookies.txt returns accessToken
    3. Logout: curl -X POST http://localhost:3000/auth/logout -H "Authorization: Bearer $TOKEN" -b cookies.txt returns success
    4. Invalid login: curl -X POST http://localhost:3000/auth/login -d '{"email":"wrong@example.com","password":"wrong"}' returns 401 with error message
  </verify>
  <done>
    All auth endpoints working: signup creates users, login returns tokens, logout invalidates tokens, refresh exchanges cookies for new access tokens, validation rejects bad input with clear errors
  </done>
</task>

</tasks>

<verification>
1. Database connection: Server starts without database errors
2. Redis connection: Server starts without redis errors
3. Signup flow: Creates user, returns 201
4. Login flow: Returns access token, sets HttpOnly cookie
5. Logout flow: Blacklists tokens, clears cookie
6. Refresh flow: Exchanges cookie for new access token
7. Error handling: Invalid credentials return 401, validation errors return 400 with field-specific messages
8. Security: Passwords hashed with bcrypt cost 12, tokens verified with algorithm whitelist
</verification>

<success_criteria>
- POST /auth/signup creates user with hashed password
- POST /auth/login returns JWT access token and sets HttpOnly refresh cookie
- POST /auth/logout invalidates both tokens via Redis blacklist
- POST /auth/refresh returns new access token from valid refresh cookie
- Validation errors return 400 with { errors: [{ field, message }] }
- Auth errors return 401 with clear error messages
- bcrypt cost factor is 12
- JWT verification whitelists HS256 algorithm
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-auth/01-02-SUMMARY.md`
</output>
