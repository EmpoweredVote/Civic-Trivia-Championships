---
phase: 06-wager-mechanics
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/types/game.ts
  - frontend/src/features/game/gameReducer.ts
  - frontend/src/features/game/hooks/useGameState.ts
  - frontend/src/services/gameService.ts
  - backend/src/services/sessionService.ts
  - backend/src/routes/game.ts
autonomous: true

must_haves:
  truths:
    - "Wager amount is validated server-side (0 to half of current score)"
    - "Final question scoring uses wager only (no base points, no speed bonus)"
    - "Timeout on final question subtracts wager amount"
    - "State machine transitions through final-announcement -> wagering -> wager-locked -> final-question phases"
    - "Wager data flows from client through API to server and back in answer response"
  artifacts:
    - path: "frontend/src/types/game.ts"
      provides: "New GamePhase values, wagerAmount/wagerCategory in GameState, wager field in GameAnswer"
      contains: "final-announcement"
    - path: "frontend/src/features/game/gameReducer.ts"
      provides: "Wager actions (START_WAGER, SET_WAGER, LOCK_WAGER, START_FINAL_QUESTION) and phase transitions"
      exports: ["gameReducer", "GameAction"]
    - path: "frontend/src/features/game/hooks/useGameState.ts"
      provides: "Wager flow methods and final question announcement timing"
      exports: ["useGameState"]
    - path: "frontend/src/services/gameService.ts"
      provides: "submitAnswer with optional wager parameter"
      exports: ["submitAnswer"]
    - path: "backend/src/services/sessionService.ts"
      provides: "Server-side wager validation, wager scoring (no base/speed, +/- wager)"
      contains: "wager"
    - path: "backend/src/routes/game.ts"
      provides: "POST /answer accepts wager field, returns wager in response"
      contains: "wager"
  key_links:
    - from: "frontend/src/features/game/hooks/useGameState.ts"
      to: "frontend/src/services/gameService.ts"
      via: "submitAnswer call with wager param"
      pattern: "submitAnswer.*wager"
    - from: "frontend/src/services/gameService.ts"
      to: "backend/src/routes/game.ts"
      via: "POST /api/game/answer with wager in body"
      pattern: "wager"
    - from: "backend/src/routes/game.ts"
      to: "backend/src/services/sessionService.ts"
      via: "sessionManager.submitAnswer with wager"
      pattern: "submitAnswer.*wager"
    - from: "frontend/src/features/game/gameReducer.ts"
      to: "frontend/src/types/game.ts"
      via: "GamePhase and GameState types"
      pattern: "final-announcement|wagering|wager-locked"
---

<objective>
Implement the complete data and logic layer for wager mechanics: types, state machine, server-side validation/scoring, API service, and game hook.

Purpose: This plan creates all the plumbing needed for the wager feature. After this plan, the state machine can transition through the full wager flow (announcement -> wagering -> locked -> final question -> reveal -> complete), the server validates and scores wagers, and the hook exposes methods for the UI to call. No UI components are created here -- that's Plan 02 and 03.

Output: Extended types, reducer, hook, API service, backend session service, and game routes with full wager support.
</objective>

<execution_context>
@C:\Users\Chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-wager-mechanics/06-CONTEXT.md
@.planning/phases/06-wager-mechanics/06-RESEARCH.md
@frontend/src/types/game.ts
@frontend/src/features/game/gameReducer.ts
@frontend/src/features/game/hooks/useGameState.ts
@frontend/src/services/gameService.ts
@backend/src/services/sessionService.ts
@backend/src/services/scoreService.ts
@backend/src/routes/game.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend types, state machine, and API service for wager flow</name>
  <files>
    frontend/src/types/game.ts
    frontend/src/features/game/gameReducer.ts
    frontend/src/services/gameService.ts
  </files>
  <action>
**frontend/src/types/game.ts:**
- Add new GamePhase values: `'final-announcement'`, `'wagering'`, `'wager-locked'`, `'final-question'` (insert between `'revealing'` and `'complete'`)
- Add to GameState type: `wagerAmount: number;` and `wagerCategory: string | null;`
- Add to GameAnswer type: `wager?: number;` (optional, only present for Q10)
- Add to GameResult type: `wagerResult?: { wagerAmount: number; won: boolean; pointsChange: number } | null;`
- Update initialGameState usage note: wagerAmount defaults to 0, wagerCategory defaults to null

**frontend/src/features/game/gameReducer.ts:**
- Add new action types to GameAction union:
  - `{ type: 'SHOW_FINAL_ANNOUNCEMENT' }` -- triggered when NEXT_QUESTION detects Q10
  - `{ type: 'START_WAGER'; category: string }` -- transitions from final-announcement to wagering
  - `{ type: 'SET_WAGER'; amount: number }` -- updates wagerAmount during wagering phase
  - `{ type: 'LOCK_WAGER' }` -- transitions from wagering to wager-locked
  - `{ type: 'START_FINAL_QUESTION' }` -- transitions from wager-locked to final-question (answering phase for Q10)
- Update initialGameState to include `wagerAmount: 0` and `wagerCategory: null`
- Modify NEXT_QUESTION case: when `nextIndex === 9` (0-indexed Q10), transition to `'final-announcement'` phase instead of `'answering'`. Set currentQuestionIndex to 9.
- Add SHOW_FINAL_ANNOUNCEMENT case: guard that phase is `'revealing'`, transition to `'final-announcement'`
- Add START_WAGER case: guard phase is `'final-announcement'`, transition to `'wagering'`, set `wagerCategory: action.category`, set `wagerAmount` to `Math.floor(Math.floor(state.totalScore / 2) * 0.25)` (default 25% of max)
- Add SET_WAGER case: guard phase is `'wagering'`, clamp amount to `[0, Math.floor(state.totalScore / 2)]`, set wagerAmount
- Add LOCK_WAGER case: guard phase is `'wagering'`, transition to `'wager-locked'`, set isTimerPaused: true
- Add START_FINAL_QUESTION case: guard phase is `'wager-locked'`, transition to `'answering'` (reuse existing answering phase for Q10), set `selectedOption: null`, set `isTimerPaused: false`
  - Important: reuse 'answering' phase for the actual Q10 so existing SELECT_ANSWER, LOCK_ANSWER, REVEAL_ANSWER, TIMEOUT all work unchanged
- Modify REVEAL_ANSWER case: when building the GameAnswer, check if `state.currentQuestionIndex === 9` and `state.wagerAmount > 0`. If so, add `wager: state.wagerAmount` to the answer. The totalPoints from scoreData already handles the wager scoring (from server).
- Modify TIMEOUT case: same check for Q10 wager, add `wager: state.wagerAmount` to answer.
- Modify the responseTime calculation in both REVEAL_ANSWER and TIMEOUT: detect final question (index 9) and use 50 instead of 25 for the calculation: `responseTime: (state.currentQuestionIndex === 9 ? 50 : 25) - action.timeRemaining`
- Reset wagerAmount and wagerCategory in SESSION_CREATED and QUIT_GAME cases

**frontend/src/services/gameService.ts:**
- Extend `submitAnswer` function signature to accept optional `wager?: number` parameter
- Include `wager` in the POST body when provided (only send if defined, don't send undefined)
- Extend the return type to include `wager?: number`

Avoid: Do NOT create a separate wager endpoint. Wager is part of answer submission per research recommendations. Do NOT use a separate state for wager outside the reducer -- it must be in GameState for phase transition integrity.
  </action>
  <verify>
Run `npx tsc --noEmit` in both frontend/ and backend/ directories. The types should compile without errors. Verify the new phases exist in the type union by checking the file.
  </verify>
  <done>
GamePhase includes 4 new wager phases. GameState has wagerAmount and wagerCategory. GameAction has 5 new wager actions. gameReducer handles all transitions including Q10 detection in NEXT_QUESTION. submitAnswer API accepts optional wager. All TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Backend wager validation, scoring, and hook wager methods</name>
  <files>
    backend/src/services/sessionService.ts
    backend/src/routes/game.ts
    frontend/src/features/game/hooks/useGameState.ts
  </files>
  <action>
**backend/src/services/sessionService.ts:**
- Add `wager?: number` field to the ServerAnswer interface
- Add a constant `FINAL_QUESTION_DURATION = 50;` (seconds, for plausibility checks on Q10)
- Extend `submitAnswer` method signature to accept optional `wager?: number` parameter
- Add wager validation inside submitAnswer BEFORE scoring:
  - Determine if this is the final question: `const questionIndex = session.questions.findIndex(q => q.id === questionId); const isFinalQuestion = questionIndex === 9;`
  - If wager is provided and NOT the final question: throw Error('Wager only allowed on final question')
  - If wager is provided: validate `wager >= 0`, validate `wager <= Math.floor(currentScore / 2)` where currentScore is `session.answers.reduce((sum, a) => sum + a.totalPoints, 0)`
  - If wager exceeds max, throw Error with message including the max value
- Add wager-specific scoring logic:
  - If `isFinalQuestion && wager !== undefined`: bypass normal calculateScore. Instead: `basePoints: 0, speedBonus: 0, totalPoints: isCorrect ? wager : -wager`
  - If `isFinalQuestion && wager === undefined`: treat as 0 wager (totalPoints: 0)
- Use `FINAL_QUESTION_DURATION` instead of `QUESTION_DURATION` for plausibility checks on Q10 (responseTime calculation and MAX_PLAUSIBLE_TIME_REMAINING check)
- Store `wager` in the ServerAnswer record
- Extend GameSessionResult interface: add `wagerResult?: { wagerAmount: number; won: boolean; pointsChange: number } | null`
- Extend `getResults` method: after calculating totals, check if the last answer (index 9) has a wager field. If so, populate wagerResult in the return value.

**backend/src/routes/game.ts:**
- In POST /answer handler: extract `wager` from req.body alongside existing fields
- Pass `wager` to `sessionManager.submitAnswer(sessionId, questionId, selectedOption ?? null, timeRemaining, wager)`
- Include `wager: answer.wager` in the response JSON (only if defined)
- In GET /results/:sessionId handler: the wagerResult will flow through automatically since getResults now returns it

**frontend/src/features/game/hooks/useGameState.ts:**
- Add constant `FINAL_QUESTION_DURATION = 50;` (seconds)
- Add constant `ANNOUNCEMENT_DURATION_MS = 2500;` (2.5s for "FINAL QUESTION" screen)
- Add constant `WAGER_SUSPENSE_MS = 1500;` (suspense pause after locking wager, matches existing lock-in feel)
- Export new methods from useGameState:
  - `startWager()`: dispatches START_WAGER with the current question's topicCategory (or topic as fallback). Called after announcement timer completes.
  - `setWagerAmount(amount: number)`: dispatches SET_WAGER with amount
  - `lockWager()`: dispatches LOCK_WAGER. After WAGER_SUSPENSE_MS delay, dispatches START_FINAL_QUESTION. This mirrors the existing lockAnswer suspense pattern.
- Modify `lockAnswer`: when `state.currentQuestionIndex === 9`, include `state.wagerAmount` in the submitAnswer call as the wager parameter
- Modify `handleTimeout`: when `state.currentQuestionIndex === 9`, include `state.wagerAmount` in the submitAnswer call as the wager parameter
- Modify the auto-advance effect: when state.phase is `'revealing'` and `state.currentQuestionIndex === 8` (Q9 just revealed), the NEXT_QUESTION dispatch will trigger the final-announcement flow. No special handling needed here -- the reducer handles the transition.
- Add effect for final-announcement phase: when `state.phase === 'final-announcement'`, start a timer for ANNOUNCEMENT_DURATION_MS, then call `startWager()`
- Extend gameResult derivation: when phase is 'complete', check if the last answer has a wager field. If so, add `wagerResult: { wagerAmount: lastAnswer.wager, won: lastAnswer.correct, pointsChange: lastAnswer.totalPoints }` to the GameResult object.
- Update UseGameStateReturn interface to include: `startWager`, `setWagerAmount`, `lockWager`, and `isFinalQuestion: boolean` (derived: `state.currentQuestionIndex === 9`)
- Add `isFinalQuestion` derived value: `const isFinalQuestion = state.currentQuestionIndex === 9;`

Avoid: Do NOT add a separate timer component for the announcement -- that's UI (Plan 02). The hook just manages the timing via setTimeout. Do NOT change the question preview behavior for Q10 -- the preview still applies. The extended timer (50s instead of 25s) will be handled by passing a different duration prop in GameScreen (Plan 02).
  </action>
  <verify>
Run `npx tsc --noEmit` in both frontend/ and backend/ directories. All types should compile. Manually verify the wager validation logic by reading sessionService.ts and confirming: (1) wager rejected on non-final questions, (2) wager clamped to half of current score, (3) scoring returns +wager for correct and -wager for incorrect, (4) timeout on Q10 applies -wager.
  </verify>
  <done>
Server validates wager (only on Q10, max half score, non-negative). Server scores Q10 with wager only (no base, no speed). Hook exposes startWager, setWagerAmount, lockWager methods. Announcement auto-transitions to wager screen after 2.5s. lockAnswer and handleTimeout include wager for Q10. gameResult includes wagerResult. TypeScript compiles cleanly in both frontend and backend.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes in both `frontend/` and `backend/` directories
2. The gameReducer handles the full transition chain: revealing (Q9) -> NEXT_QUESTION -> final-announcement -> START_WAGER -> wagering -> SET_WAGER -> LOCK_WAGER -> wager-locked -> START_FINAL_QUESTION -> answering (Q10) -> normal answer flow -> complete
3. Server-side submitAnswer with wager=500 on Q10 with score 1200 succeeds (max wager 600)
4. Server-side submitAnswer with wager=700 on Q10 with score 1200 throws error (exceeds max 600)
5. Server-side submitAnswer with wager on Q5 throws error (not final question)
6. Correct Q10 answer with wager=300 returns totalPoints: 300
7. Incorrect/timeout Q10 answer with wager=300 returns totalPoints: -300
</verification>

<success_criteria>
- All 4 new GamePhase values exist in types
- GameState includes wagerAmount and wagerCategory
- gameReducer handles 5 new action types with proper phase guards
- NEXT_QUESTION detects Q10 and routes to final-announcement
- Server validates wager bounds and rejects invalid wagers
- Server scores Q10 with wager-only logic (no base/speed)
- Hook exposes wager methods and auto-transitions announcement to wager
- gameResult includes wagerResult for results screen consumption
- Both frontend and backend compile without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-wager-mechanics/06-01-SUMMARY.md`
</output>
