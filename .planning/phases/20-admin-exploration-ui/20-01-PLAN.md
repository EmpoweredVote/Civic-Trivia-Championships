---
phase: 20-admin-exploration-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/routes/admin.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/admin/questions returns paginated question list with collection names, quality scores, and telemetry counts"
    - "GET /api/admin/questions/:id returns full question detail including options, explanation, source, and computed violations"
    - "GET /api/admin/collections/health returns per-collection stats including question count, difficulty distribution, quality score summary, and telemetry aggregates"
    - "All three endpoints require admin authentication and return 401/403 for unauthorized requests"
    - "Question list supports server-side filtering by collection, difficulty, status, and search text"
    - "Question list supports server-side sorting by quality_score, difficulty, encounter_count, correct_count, created_at"
    - "Pagination metadata (page, limit, total, pages) is always returned with list endpoint"
  artifacts:
    - path: "backend/src/routes/admin.ts"
      provides: "Three new admin API endpoints for question listing, detail, and collection health"
      contains: "router.get.*questions.*page"
  key_links:
    - from: "backend/src/routes/admin.ts"
      to: "backend/src/db/schema.ts"
      via: "Drizzle ORM queries with dynamic filtering"
      pattern: "questions.*qualityScore|collectionQuestions"
    - from: "backend/src/routes/admin.ts"
      to: "backend/src/services/qualityRules/index.ts"
      via: "auditQuestion import for detail endpoint"
      pattern: "auditQuestion.*skipUrlCheck"
---

<objective>
Create the three admin API endpoints that power the Phase 20 exploration UI: a paginated question list with filtering/sorting, a question detail endpoint with computed quality violations, and a collection health stats endpoint.

Purpose: The frontend exploration UI (Plans 02 and 03) cannot be built without backend data. These endpoints are the data foundation for the entire phase.
Output: Three new GET endpoints on the existing admin router, all protected by existing authenticateToken + requireAdmin middleware.
</objective>

<execution_context>
@C:\Users\Chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-admin-exploration-ui/20-CONTEXT.md
@.planning/phases/20-admin-exploration-ui/20-RESEARCH.md

# Existing code to extend
@backend/src/routes/admin.ts
@backend/src/db/schema.ts
@backend/src/services/qualityRules/index.ts
@backend/src/services/qualityRules/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Question list and detail API endpoints</name>
  <files>backend/src/routes/admin.ts</files>
  <action>
Add two new endpoints to the existing admin router in backend/src/routes/admin.ts. The router already has `router.use(authenticateToken, requireAdmin)` applied globally, so no auth middleware needed per-route.

**Endpoint 1: GET /api/admin/questions/explore**

Use a distinct path (`/explore`) to avoid conflict with the existing `/questions` route (which handles expired/expiring questions from v1.2).

Query params:
- `page` (integer, default 1)
- `limit` (integer, default 25, max 100)
- `sort` (string, one of: quality_score, difficulty, encounter_count, correct_count, created_at; default: quality_score)
- `order` (string, 'asc' or 'desc', default: 'asc' -- surfaces lowest quality first per CONTEXT.md decision)
- `collection` (string, collection slug -- filter by collection)
- `difficulty` (string, 'easy' | 'medium' | 'hard')
- `status` (string, 'active' | 'archived' | 'expired')
- `search` (string, ILIKE search across question text, options JSONB cast to text, and explanation)

Implementation:
1. Validate query params with basic sanitization (parseInt for page/limit, whitelist for sort/order columns)
2. Build dynamic WHERE clause array using Drizzle's `and()`, `eq()`, `ilike()`, `or()`, `sql` template
3. Join questions -> collectionQuestions -> collections to get collection names via `array_agg(DISTINCT collections.name)`
4. Group by questions.id
5. For collection filter: join and filter with `eq(collections.slug, collection)`
6. For search: use `or(ilike(questions.text, searchPattern), sql\`${questions.options}::text ILIKE ${searchPattern}\`, ilike(questions.explanation, searchPattern))`
7. For quality_score sorting: ALWAYS use `NULLS LAST` (matches Phase 19 index convention)
8. Run count query separately (COUNT DISTINCT questions.id) with same filters but no pagination
9. Apply LIMIT/OFFSET for pagination
10. Return `{ data: [...], pagination: { page, limit, total, pages } }`

Each question in data array should include: id, externalId, text (truncated to 120 chars for table display), difficulty, qualityScore, status, encounterCount, correctCount, createdAt, collectionNames (string array).

Import additions needed: `ilike`, `desc`, `asc` from 'drizzle-orm' (add to existing import). Also import `sql` if not already imported (it is already imported).

IMPORTANT: Do NOT touch or remove the existing GET /questions route. Add the new route at a DIFFERENT path: `/questions/explore`.

**Endpoint 2: GET /api/admin/questions/:id/detail**

Fetch a single question by its numeric `id` (primary key):
1. Select full question row (all columns) from questions table
2. Join collectionQuestions + collections to get collection names array
3. If question not found, return 404
4. Import `auditQuestion` from `../../services/qualityRules/index.js` and `QuestionInput` from types
5. Map the DB question to QuestionInput format: { text, options, correctAnswer, explanation, difficulty, source, externalId }
6. Run `auditQuestion(questionInput, { skipUrlCheck: true })` -- skip URL check for fast response (per RESEARCH.md recommendation: compute on-demand, no URL blocking)
7. Return: `{ question: { ...fullQuestionRow, collectionNames }, audit: { score, violations, hasBlockingViolations, hasAdvisoryOnly } }`

This gives the detail panel everything it needs: full question content + quality assessment.
  </action>
  <verify>
Run `npx tsx` to check TypeScript compilation:
```
cd backend && npx tsc --noEmit
```
Verify the file has both new route handlers by checking for `/questions/explore` and `/questions/:id/detail` patterns.
  </verify>
  <done>
GET /api/admin/questions/explore returns paginated, filtered, sorted question list with collection names and pagination metadata. GET /api/admin/questions/:id/detail returns full question with quality audit results. Both endpoints require admin auth (via existing router.use middleware). Existing /questions route is untouched.
  </done>
</task>

<task type="auto">
  <name>Task 2: Collection health API endpoint</name>
  <files>backend/src/routes/admin.ts</files>
  <action>
Add one more endpoint to the admin router:

**Endpoint: GET /api/admin/collections/health**

This endpoint computes aggregate health stats for ALL active collections. It powers the collection health dashboard cards.

Implementation:
1. Query all collections (both active and inactive, so admin can see everything)
2. For each collection, compute stats using a single aggregated SQL query:

Use a single query with Drizzle that joins collections -> collectionQuestions -> questions and groups by collection:

```sql
SELECT
  c.id, c.name, c.slug, c.is_active, c.theme_color,
  COUNT(DISTINCT q.id) FILTER (WHERE q.status = 'active') as active_count,
  COUNT(DISTINCT q.id) FILTER (WHERE q.status = 'archived') as archived_count,
  COUNT(DISTINCT q.id) as total_count,
  -- Difficulty distribution
  COUNT(DISTINCT q.id) FILTER (WHERE q.difficulty = 'easy' AND q.status = 'active') as easy_count,
  COUNT(DISTINCT q.id) FILTER (WHERE q.difficulty = 'medium' AND q.status = 'active') as medium_count,
  COUNT(DISTINCT q.id) FILTER (WHERE q.difficulty = 'hard' AND q.status = 'active') as hard_count,
  -- Quality score stats (active questions only)
  AVG(q.quality_score) FILTER (WHERE q.status = 'active' AND q.quality_score IS NOT NULL) as avg_quality_score,
  MIN(q.quality_score) FILTER (WHERE q.status = 'active' AND q.quality_score IS NOT NULL) as min_quality_score,
  COUNT(q.id) FILTER (WHERE q.status = 'active' AND q.quality_score IS NULL) as unscored_count,
  -- Telemetry aggregates (active questions only)
  SUM(q.encounter_count) FILTER (WHERE q.status = 'active') as total_encounters,
  SUM(q.correct_count) FILTER (WHERE q.status = 'active') as total_correct
FROM civic_trivia.collections c
LEFT JOIN civic_trivia.collection_questions cq ON c.id = cq.collection_id
LEFT JOIN civic_trivia.questions q ON cq.question_id = q.id
GROUP BY c.id
ORDER BY c.sort_order
```

Use Drizzle's `sql` template literal to express the FILTER clauses (Drizzle doesn't have native FILTER support, so use raw sql for the aggregations).

3. Map results to response shape:
```typescript
{
  collections: [{
    id, name, slug, isActive, themeColor,
    stats: {
      activeCount, archivedCount, totalCount,
      difficulty: { easy, medium, hard },
      quality: { avgScore (rounded to integer), minScore, unscoredCount },
      telemetry: { totalEncounters, totalCorrect, overallCorrectRate (percentage, null if 0 encounters) }
    }
  }]
}
```

4. overallCorrectRate = totalEncounters > 0 ? Math.round((totalCorrect / totalEncounters) * 100) : null

This gives the frontend everything it needs in a single API call -- no N+1 queries.
  </action>
  <verify>
Run TypeScript compilation:
```
cd backend && npx tsc --noEmit
```
Verify the route exists by checking for `/collections/health` in admin.ts.
  </verify>
  <done>
GET /api/admin/collections/health returns an array of all collections with aggregated stats (counts, difficulty distribution, quality scores, telemetry). Single SQL query with no N+1 problem. Response shape documented and consistent.
  </done>
</task>

</tasks>

<verification>
1. `cd backend && npx tsc --noEmit` -- TypeScript compiles without errors
2. All three endpoints exist in admin.ts: `/questions/explore`, `/questions/:id/detail`, `/collections/health`
3. Existing routes (GET /questions, POST /questions/:id/renew, POST /questions/:id/archive) are untouched
4. No new npm dependencies added
5. Quality rules engine imported and used only in the detail endpoint (not in list or health)
</verification>

<success_criteria>
- Three new admin API endpoints added to backend/src/routes/admin.ts
- Question list supports pagination (page, limit), sorting (5 columns with NULLS LAST for quality_score), filtering (collection, difficulty, status, search)
- Question detail returns full question with on-demand quality audit (skipUrlCheck: true)
- Collection health returns per-collection aggregate stats in single query
- All endpoints protected by existing admin middleware
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/20-admin-exploration-ui/20-01-SUMMARY.md`
</output>
