---
phase: 15-collection-picker-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/routes/game.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/game/collections returns active collections with question counts"
    - "Collections with fewer than 10 active (non-expired) questions are excluded"
    - "Results are ordered by sortOrder (Federal Civics first)"
  artifacts:
    - path: "backend/src/routes/game.ts"
      provides: "GET /collections endpoint"
      contains: "router.get('/collections'"
  key_links:
    - from: "backend/src/routes/game.ts"
      to: "backend/src/db/schema.ts"
      via: "Drizzle ORM query on collections + collectionQuestions tables"
      pattern: "collections.*collectionQuestions"
---

<objective>
Add GET /api/game/collections backend endpoint that returns active collections with question counts.

Purpose: The collection picker UI needs a data source. This endpoint provides the list of playable collections with metadata and active question counts, filtering out collections below the minimum question threshold and excluding expired questions from counts.

Output: A new route handler in game.ts that queries collections joined with collectionQuestions, filters by isActive and question threshold, and returns JSON.
</objective>

<execution_context>
@C:\Users\Chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@backend/src/routes/game.ts
@backend/src/db/schema.ts
@backend/src/services/questionService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add GET /collections endpoint to game routes</name>
  <files>backend/src/routes/game.ts</files>
  <action>
Add a new route handler `router.get('/collections', ...)` in `backend/src/routes/game.ts`. This endpoint:

1. Import `collections`, `collectionQuestions`, and `questions` from `../db/schema.js`, plus `eq` and `sql` from `drizzle-orm`, and `db` from `../db/index.js` (follow existing import patterns in the file or in `questionService.ts`).

2. Query active collections with question counts:
   - SELECT collections.id, collections.name, collections.slug, collections.description, collections.themeColor, COUNT(collectionQuestions.questionId)::int as questionCount
   - LEFT JOIN collectionQuestions ON collections.id = collectionQuestions.collectionId
   - LEFT JOIN questions ON collectionQuestions.questionId = questions.id
   - WHERE collections.isActive = true
   - AND (questions.expiresAt IS NULL OR questions.expiresAt > NOW()) â€” exclude expired questions from count
   - GROUP BY collections.id
   - ORDER BY collections.sortOrder ASC

3. Define `MIN_QUESTION_THRESHOLD = 10` as a constant at module level.

4. Filter the query results in JS: `rows.filter(r => r.questionCount >= MIN_QUESTION_THRESHOLD)`.

5. Return `res.json({ collections: filtered })`.

6. Wrap in try/catch, log errors with `console.error`, return 500 on failure.

IMPORTANT: The join must go through the `questions` table to check `expiresAt`, not just count from `collectionQuestions` alone. This prevents showing inflated counts when questions have expired.

Place this route BEFORE the existing `router.get('/questions', ...)` route (order doesn't matter for different paths, but keep GET routes grouped together at the top).
  </action>
  <verify>
Run `npx tsx -e "import('./backend/src/routes/game.ts')"` or check TypeScript compilation with `cd backend && npx tsc --noEmit` to verify no type errors. If the backend can start, do a quick `curl http://localhost:3001/api/game/collections` to confirm the response shape.
  </verify>
  <done>
GET /api/game/collections returns JSON with `{ collections: [...] }` where each collection has id, name, slug, description, themeColor, and questionCount. Only active collections with >= 10 non-expired questions are included, ordered by sortOrder.
  </done>
</task>

</tasks>

<verification>
- TypeScript compiles without errors (`cd backend && npx tsc --noEmit`)
- Backend starts without crash
- GET /api/game/collections returns expected shape with Federal Civics collection
- Inactive collections (Bloomington, LA) are NOT returned
- Question count excludes expired questions
</verification>

<success_criteria>
The collections endpoint is live and returns the correct data shape for the frontend picker to consume.
</success_criteria>

<output>
After completion, create `.planning/phases/15-collection-picker-ui/15-01-SUMMARY.md`
</output>
