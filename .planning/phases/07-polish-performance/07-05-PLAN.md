---
phase: 07-polish-performance
plan: 05
type: execute
wave: 3
depends_on: ["07-03", "07-04"]
files_modified:
  - frontend/src/store/confettiStore.ts
  - frontend/src/components/animations/ConfettiController.tsx
  - frontend/src/components/animations/CelebrationEffects.tsx
  - frontend/src/features/game/components/GameScreen.tsx
  - frontend/src/features/game/components/ResultsScreen.tsx
  - frontend/src/features/game/gameReducer.ts
  - frontend/src/types/game.ts
  - frontend/src/App.tsx
  - frontend/src/hooks/useWebVitals.ts
autonomous: true

must_haves:
  truths:
    - "3-correct streak triggers small confetti burst"
    - "5-correct streak triggers bigger burst with 'On Fire!' label"
    - "7+ streak triggers dramatic celebration with 'Unstoppable!' label"
    - "Perfect game (10/10) triggers full-screen confetti rain on results screen"
    - "Animations respect prefers-reduced-motion (static indicators instead)"
    - "Question transitions are smooth cross-fades"
    - "Animations run at 60fps (transform/opacity only)"
    - "Web Vitals monitoring active in production"
  artifacts:
    - path: "frontend/src/store/confettiStore.ts"
      provides: "Zustand store for confetti trigger methods"
      exports: ["useConfettiStore"]
    - path: "frontend/src/components/animations/ConfettiController.tsx"
      provides: "Canvas-based confetti conductor component"
      exports: ["ConfettiController"]
    - path: "frontend/src/components/animations/CelebrationEffects.tsx"
      provides: "Streak celebration overlay component"
      exports: ["CelebrationEffects"]
    - path: "frontend/src/hooks/useWebVitals.ts"
      provides: "Web Vitals monitoring hook"
      exports: ["useWebVitals"]
  key_links:
    - from: "frontend/src/features/game/components/GameScreen.tsx"
      to: "frontend/src/store/confettiStore.ts"
      via: "streak detection triggers confetti"
      pattern: "currentStreak.*fire|confetti"
    - from: "frontend/src/features/game/components/ResultsScreen.tsx"
      to: "frontend/src/store/confettiStore.ts"
      via: "perfect game triggers confetti rain"
      pattern: "isPerfectGame.*confetti|fireConfettiRain"
    - from: "frontend/src/App.tsx"
      to: "frontend/src/components/animations/ConfettiController.tsx"
      via: "mounted once at app level"
      pattern: "<ConfettiController"
---

<objective>
Implement game-show celebration effects and performance optimization (PERF-04). Add confetti celebrations for streaks and perfect games, streak tracking in game state, question transition polish, useReducedMotion integration, and Web Vitals monitoring.

Purpose: Delivers the polished game-show aesthetic with escalating celebrations that reward sustained performance, while ensuring 60fps animation performance.
Output: Full celebration system with streak tracking, confetti effects, and performance monitoring.
</objective>

<execution_context>
@C:\Users\Chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:\Project Test\.planning\PROJECT.md
@C:\Project Test\.planning\ROADMAP.md
@C:\Project Test\.planning\phases\07-polish-performance\07-CONTEXT.md
@C:\Project Test\.planning\phases\07-polish-performance\07-RESEARCH.md

Key existing files:
@C:\Project Test\frontend\src\features\game\components\GameScreen.tsx
@C:\Project Test\frontend\src\features\game\components\ResultsScreen.tsx
@C:\Project Test\frontend\src\features\game\gameReducer.ts
@C:\Project Test\frontend\src\types\game.ts
@C:\Project Test\frontend\src\App.tsx
@C:\Project Test\frontend\src\hooks\useReducedMotion.ts
@C:\Project Test\frontend\src\main.tsx

Prior plan summaries (07-01, 07-03, 07-04 must be complete):
@C:\Project Test\.planning\phases\07-polish-performance\07-01-PLAN.md
@C:\Project Test\.planning\phases\07-polish-performance\07-03-PLAN.md
@C:\Project Test\.planning\phases\07-polish-performance\07-04-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Streak tracking and confetti celebration system</name>
  <files>
    frontend/src/features/game/gameReducer.ts
    frontend/src/types/game.ts
    frontend/src/store/confettiStore.ts
    frontend/src/components/animations/ConfettiController.tsx
    frontend/src/components/animations/CelebrationEffects.tsx
    frontend/src/App.tsx
  </files>
  <action>
    1. Update `frontend/src/types/game.ts`:
       - Add `currentStreak: number` to `GameState` type (tracks consecutive correct answers)

    2. Update `frontend/src/features/game/gameReducer.ts`:
       - Add `currentStreak: 0` to `initialGameState`
       - In REVEAL_ANSWER case: if `action.scoreData.correct`, increment `currentStreak: state.currentStreak + 1`; else reset to `currentStreak: 0`
       - In TIMEOUT case: reset `currentStreak: 0`
       - In SESSION_CREATED case: reset `currentStreak: 0`

    3. Create `frontend/src/store/confettiStore.ts`:
       - Zustand store with fire methods:
         ```ts
         interface ConfettiStore {
           conductor: any | null;
           setConductor: (conductor: any) => void;
           fireSmallBurst: () => void;
           fireMediumBurst: () => void;
           fireConfettiRain: () => void;
         }
         ```
       - `fireSmallBurst`: calls `conductor?.shoot()` (quick single burst)
       - `fireMediumBurst`: calls `conductor?.run({ speed: 3, duration: 1500 })` (bigger effect)
       - `fireConfettiRain`: calls `conductor?.run({ speed: 1, duration: 5000 })` (sustained rain)
       - Each fire method should be a no-op if conductor is null

    4. Create `frontend/src/components/animations/ConfettiController.tsx`:
       - Import Fireworks from 'react-canvas-confetti/dist/presets/fireworks' (check the actual import path from the library - may be `react-canvas-confetti/dist/presets/fireworks` or similar)
       - Actually, check react-canvas-confetti v2 API. The library may use a different pattern. From the research:
         ```tsx
         import ReactCanvasConfetti from 'react-canvas-confetti';
         ```
         With a conductor pattern. Reference the library docs during implementation.
       - Render a fixed-position canvas covering the full viewport:
         ```tsx
         style={{
           position: 'fixed',
           pointerEvents: 'none',
           width: '100%',
           height: '100%',
           top: 0,
           left: 0,
           zIndex: 9999,
         }}
         ```
       - On mount, store the conductor reference in the confettiStore via `setConductor`
       - Import `useReducedMotion` hook - if reduced motion is preferred, don't render the canvas at all (return null)

    5. Create `frontend/src/components/animations/CelebrationEffects.tsx`:
       - Props: `{ streak: number }`
       - Renders a floating label for streak milestones:
         - 3-streak: Small burst animation + no label (just visual confetti from ConfettiController)
         - 5-streak: Label "On Fire!" with orange/amber styling, animated scale-in
         - 7+ streak: Label "Unstoppable!" with gold styling, more dramatic animation
       - Use motion.div with:
         ```tsx
         initial={{ scale: 0, opacity: 0, y: 20 }}
         animate={{ scale: 1, opacity: 1, y: 0 }}
         exit={{ scale: 1.2, opacity: 0 }}
         ```
       - Position: fixed center of screen, above game content (z-index 40), pointer-events-none
       - Auto-dismiss after 2 seconds
       - Import `useReducedMotion` - if reduced motion, show a simple static badge instead of animated label
       - Only show when streak CHANGES to a milestone value (3, 5, 7, 8, 9, 10...)

    6. Update `frontend/src/App.tsx`:
       - Import and render ConfettiController as a sibling to the existing components (NOT inside Routes)
       - Place after LiveRegions, before AuthInitializer:
         ```tsx
         <SkipToContent />
         <LiveRegions />
         <ConfettiController />
         <AuthInitializer>
           <main id="main-content" tabIndex={-1}>
             <Routes>...</Routes>
           </main>
         </AuthInitializer>
         ```
  </action>
  <verify>
    Run `cd frontend && npm run build` to verify compilation. Check that gameReducer tracks currentStreak, confettiStore has fire methods, ConfettiController renders canvas, CelebrationEffects shows labels, App.tsx mounts ConfettiController.
  </verify>
  <done>
    Game state tracks currentStreak (increments on correct, resets on wrong/timeout). Confetti store provides fireSmallBurst, fireMediumBurst, and fireConfettiRain methods. ConfettiController renders a persistent canvas overlay. CelebrationEffects component shows streak labels at milestones. All animation components respect prefers-reduced-motion.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire celebrations to game events and polish question transitions</name>
  <files>
    frontend/src/features/game/components/GameScreen.tsx
    frontend/src/features/game/components/ResultsScreen.tsx
  </files>
  <action>
    1. Update `GameScreen.tsx` to trigger celebrations on streaks:
       - Import `useConfettiStore` from confettiStore
       - Import `CelebrationEffects` component
       - Import `useReducedMotion` hook
       - Add a useEffect watching `state.currentStreak`:
         ```ts
         const { fireSmallBurst, fireMediumBurst } = useConfettiStore();
         const reducedMotion = useReducedMotion();

         useEffect(() => {
           if (reducedMotion) return; // Skip confetti for reduced motion
           if (state.currentStreak === 3) {
             fireSmallBurst();
           } else if (state.currentStreak === 5) {
             fireMediumBurst();
             announce.polite('On Fire! 5 in a row!');
           } else if (state.currentStreak >= 7) {
             fireMediumBurst();
             if (state.currentStreak === 7) {
               announce.polite('Unstoppable! 7 in a row!');
             }
           }
         }, [state.currentStreak]);
         ```
       - Render CelebrationEffects component:
         ```tsx
         <CelebrationEffects streak={state.currentStreak} />
         ```
         Place it outside the main content flow but inside the game container (fixed positioning handles placement)

    2. Polish question transitions in GameScreen:
       - The existing AnimatePresence mode="wait" with motion.div already handles transitions
       - Current animation: `initial={{ opacity: 0, y: 20 }}` `animate={{ opacity: 1, y: 0 }}` `exit={{ opacity: 0, y: -20 }}`
       - This is already a smooth cross-fade with vertical slide. Enhance slightly:
         - Keep the cross-fade (it's clean and fast)
         - Ensure exit animation is `exit={{ opacity: 0, x: -30 }}` for a subtle left-slide-out
         - Entry animation: `initial={{ opacity: 0, x: 30 }}` for right-slide-in
         - Duration stays at 0.3s (fast, doesn't delay gameplay)
       - Import useReducedMotion: if preferred, set transition duration to 0 (instant swap)

    3. Update `ResultsScreen.tsx` for perfect game celebration:
       - Import `useConfettiStore`
       - Import `useReducedMotion`
       - Import `announce` from utils/announce
       - When `isPerfectGame` is true, in a useEffect on mount:
         ```ts
         const { fireConfettiRain } = useConfettiStore();
         const reducedMotion = useReducedMotion();

         useEffect(() => {
           if (isPerfectGame) {
             if (!reducedMotion) {
               fireConfettiRain(); // 5-second confetti rain
             }
             announce.polite('Perfect game! You answered all 10 questions correctly!');
           }
         }, [isPerfectGame]);
         ```
       - The existing golden treatment (text-yellow-400, text shadow, "Perfect Game!" label) stays as-is
       - For reduced motion users: the golden text treatment and label are sufficient visual feedback

    4. Ensure all animations use GPU-only properties:
       - Check all motion.div/motion.button animations in GameScreen and ResultsScreen
       - They should ONLY animate: opacity, transform (scale, x, y, rotate)
       - If any animate width, height, background-color, etc.: switch to CSS class toggles instead
       - The existing animations in the codebase already follow this pattern (checked: scale, opacity, x, y)
       - Verify the score counter spring animation uses useMotionValue (it does - confirmed in ResultsScreen)
  </action>
  <verify>
    Run `cd frontend && npm run build` to verify compilation. Check GameScreen has streak celebration wiring and updated transition animations. Check ResultsScreen fires confetti on perfect game.
  </verify>
  <done>
    Streak celebrations fire at 3/5/7+ correct answers in a row with escalating confetti and labels. Perfect game triggers full-screen confetti rain on results screen. Question transitions use smooth cross-fade with subtle horizontal slide. All animations use only transform/opacity (GPU-accelerated). Reduced motion users see static indicators instead of animations. Screen reader announces streak milestones and perfect game.
  </done>
</task>

<task type="auto">
  <name>Task 3: Web Vitals monitoring and performance optimization</name>
  <files>
    frontend/src/hooks/useWebVitals.ts
    frontend/src/main.tsx
  </files>
  <action>
    1. Create `frontend/src/hooks/useWebVitals.ts`:
       - Import `onCLS`, `onINP`, `onLCP` from 'web-vitals'
       - Create hook that sets up monitoring on mount:
         ```ts
         export function useWebVitals() {
           useEffect(() => {
             // Log to console in development, could send to analytics in production
             const logMetric = (metric: { name: string; value: number; rating: string }) => {
               if (import.meta.env.DEV) {
                 const emoji = metric.rating === 'good' ? '[GOOD]' : metric.rating === 'needs-improvement' ? '[NEEDS IMPROVEMENT]' : '[POOR]';
                 console.log(`[Web Vitals] ${metric.name}: ${Math.round(metric.value)} ${emoji}`);
               }
             };

             onCLS(logMetric);
             onINP(logMetric);
             onLCP(logMetric);
           }, []);
         }
         ```
       - Thresholds for reference (not enforced, just logged):
         - CLS: good < 0.1, poor > 0.25
         - INP: good < 200ms, poor > 500ms
         - LCP: good < 2500ms, poor > 4000ms

    2. Update `frontend/src/main.tsx`:
       - Import and call `useWebVitals` at the app level
       - Since main.tsx renders the root, we need to call it inside a component. The simplest approach:
         - Create a small wrapper or call it in App.tsx instead
       - Actually, better: call it in App.tsx (already has component structure)
       - Update plan: Add `useWebVitals()` call inside the App component in App.tsx
       - But App.tsx is already modified by plan 07-01. Since this plan depends on 07-01, App.tsx should have the accessibility additions.
       - Add `useWebVitals()` at the top of the App function body (it's a passive monitoring hook, no output)

    3. Performance optimization notes (no new files, guidance for executor):
       - The existing codebase already uses:
         - Zustand with selector subscriptions (fine-grained re-renders)
         - Framer Motion for animations (GPU-accelerated)
         - useMotionValue/useSpring for score counters
       - The new confetti uses canvas (separate from React render cycle)
       - No additional React.memo wrapping needed unless profiling shows issues
       - The key performance concern is the confetti canvas - it's already pointer-events: none and only active during celebrations (not persistent particles)
       - Web Vitals monitoring will surface any issues

    Actually, update the files_modified to include App.tsx for the useWebVitals addition.
  </action>
  <verify>
    Run `cd frontend && npm run build` to verify compilation. Check that useWebVitals hook exists and is called in App.tsx. Check console output in development mode shows Web Vitals metrics.
  </verify>
  <done>
    Web Vitals (CLS, INP, LCP) are monitored and logged to console in development. All animations verified to use GPU-only properties (transform, opacity). Confetti uses canvas rendering (separate from React lifecycle). Performance monitoring ready for production analytics integration.
  </done>
</task>

</tasks>

<verification>
- `cd frontend && npm run build` succeeds
- gameReducer tracks currentStreak in state
- confettiStore has three fire methods wired to conductor
- ConfettiController mounted in App.tsx
- GameScreen triggers confetti at streak milestones (3, 5, 7+)
- GameScreen shows CelebrationEffects labels at streak milestones
- ResultsScreen fires confetti rain on perfect game
- All animations use transform/opacity only
- useReducedMotion disables confetti and animated labels
- useWebVitals logs CLS/INP/LCP in development
- Question transitions use cross-fade with horizontal slide
</verification>

<success_criteria>
- 3-streak: small confetti burst fires
- 5-streak: bigger confetti + "On Fire!" label appears
- 7+ streak: dramatic confetti + "Unstoppable!" label
- Perfect game (10/10): full-screen confetti rain lasting 5 seconds on results
- Reduced motion: confetti disabled, static labels/badges shown instead
- Question transitions: smooth 300ms cross-fade with horizontal slide
- All animations GPU-accelerated (transform/opacity only)
- Web Vitals monitored and logged in dev
- Frontend builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-polish-performance/07-05-SUMMARY.md`
</output>
