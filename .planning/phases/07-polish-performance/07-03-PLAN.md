---
phase: 07-polish-performance
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - frontend/src/features/game/components/GameScreen.tsx
  - frontend/src/features/game/components/AnswerGrid.tsx
  - frontend/src/features/game/components/GameTimer.tsx
  - frontend/src/features/game/components/WagerScreen.tsx
  - frontend/src/features/game/components/ResultsScreen.tsx
  - frontend/src/features/game/components/PauseOverlay.tsx
  - frontend/src/features/game/hooks/useKeyPress.ts
  - frontend/src/features/game/gameReducer.ts
  - frontend/src/types/game.ts
autonomous: true

must_haves:
  truths:
    - "Arrow keys navigate between answer options, Enter/Space locks in"
    - "Number keys 1-4 directly select answer options"
    - "Escape key pauses the game timer during active gameplay"
    - "Pause overlay hides question text and offers Resume and Quit options"
    - "Focus is trapped within pause overlay when visible"
    - "Wager slider responds to Arrow keys (10pt steps) and PageUp/PageDown (50pt jumps)"
    - "Screen reader announces timer at 10s, 5s, and 0s thresholds"
    - "Screen reader announces answer result with correct answer and points earned"
    - "Question 1 and Final Question are announced to screen readers"
  artifacts:
    - path: "frontend/src/features/game/components/PauseOverlay.tsx"
      provides: "Pause overlay with focus trap, hides question"
      exports: ["PauseOverlay"]
    - path: "frontend/src/features/game/components/AnswerGrid.tsx"
      provides: "Keyboard navigable answer buttons with arrow/number key support"
      contains: "onKeyDown"
  key_links:
    - from: "frontend/src/features/game/components/GameScreen.tsx"
      to: "PauseOverlay"
      via: "Escape key handler triggers pause state"
      pattern: "Escape.*pause|isPaused"
    - from: "frontend/src/features/game/components/GameTimer.tsx"
      to: "frontend/src/utils/announce.ts"
      via: "announce.polite at timer thresholds"
      pattern: "announce\\.polite.*seconds remaining"
    - from: "frontend/src/features/game/components/AnswerGrid.tsx"
      to: "keyboard navigation"
      via: "onKeyDown handlers on buttons"
      pattern: "ArrowDown|ArrowUp|Enter"
---

<objective>
Implement full keyboard navigation (A11Y-01) and screen reader announcements (A11Y-02) for the game. Add arrow key + number key answer selection, Escape-key pause functionality with overlay, wager slider keyboard support, results accordion keyboard navigation, and all screen reader announcement triggers.

Purpose: Makes the entire game playable without a mouse and accessible to screen reader users.
Output: Fully keyboard-navigable game with pause functionality and screen reader announcements at key moments.
</objective>

<execution_context>
@C:\Users\Chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:\Project Test\.planning\PROJECT.md
@C:\Project Test\.planning\ROADMAP.md
@C:\Project Test\.planning\phases\07-polish-performance\07-CONTEXT.md
@C:\Project Test\.planning\phases\07-polish-performance\07-RESEARCH.md

Key existing files:
@C:\Project Test\frontend\src\features\game\components\GameScreen.tsx
@C:\Project Test\frontend\src\features\game\components\AnswerGrid.tsx
@C:\Project Test\frontend\src\features\game\components\GameTimer.tsx
@C:\Project Test\frontend\src\features\game\components\WagerScreen.tsx
@C:\Project Test\frontend\src\features\game\components\ResultsScreen.tsx
@C:\Project Test\frontend\src\features\game\hooks\useKeyPress.ts
@C:\Project Test\frontend\src\features\game\gameReducer.ts
@C:\Project Test\frontend\src\types\game.ts

Prior plan context (07-01 must be complete):
@C:\Project Test\.planning\phases\07-polish-performance\07-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Keyboard navigation for answers, wager slider, and results accordions</name>
  <files>
    frontend/src/features/game/components/AnswerGrid.tsx
    frontend/src/features/game/components/WagerScreen.tsx
    frontend/src/features/game/components/ResultsScreen.tsx
    frontend/src/features/game/components/GameScreen.tsx
  </files>
  <action>
    1. Update `AnswerGrid.tsx` to support arrow keys + number keys + Enter/Space:
       - Add a `focusedIndex` state (number | null, starts at null)
       - Each answer button gets a ref via useRef array pattern
       - Add `onKeyDown` handler to each button:
         - ArrowDown: move focusedIndex to next (wraps from 3 to 0)
         - ArrowUp: move focusedIndex to prev (wraps from 0 to 3)
         - Enter or Space: if in 'selected' phase, call onLockIn; if in 'answering' phase, call onSelect(focusedIndex) then onLockIn. If no option selected yet, call onSelect(focusedIndex)
         - '1', '2', '3', '4': call onSelect(parseInt(key) - 1) for direct selection
       - When focusedIndex changes, call `.focus()` on the corresponding button ref
       - When canSelect becomes false (locked/revealing), reset focusedIndex to null
       - Add `aria-label` to each button: `"Option ${OPTION_LETTERS[index]}: ${option}"`
       - The Lock In button should get `className="focus-ring-primary"` for amber focus ring
       - Add `tabIndex={0}` to first answer button, `tabIndex={-1}` to others (roving tabindex pattern)
       - When focusedIndex is set, the focused button gets tabIndex={0}, others get tabIndex={-1}

    2. Update `GameScreen.tsx` keyboard handling:
       - REMOVE the existing useKeyPress('a'/'b'/'c'/'d') calls (lines ~151-154) since AnswerGrid now handles keyboard internally
       - Keep the useKeyPress('l', ...) for Learn More shortcut
       - Add number key handlers at the GameScreen level for when AnswerGrid might not have focus:
         - Listen for '1','2','3','4' keys globally (via useEffect + window.addEventListener)
         - Only active when `canUseKeyboard` is true
         - These call selectAnswer(index) and should also focus the corresponding answer button
       - Actually, simpler approach: keep keyboard handling at GameScreen level for number keys, let AnswerGrid handle arrow keys + Enter/Space internally. The AnswerGrid arrow navigation only works when an answer button has focus.

    3. Update `WagerScreen.tsx` for keyboard support:
       - The range input already supports arrow keys natively (browser default)
       - Add `onKeyDown` handler to the range input:
         - ArrowLeft/ArrowDown: decrease by 10 (step already is 10, native handles this)
         - ArrowRight/ArrowUp: increase by 10 (native handles this)
         - PageDown: decrease by 50 - `onSetWager(Math.max(0, wagerAmount - 50))`
         - PageUp: increase by 50 - `onSetWager(Math.min(maxWager, wagerAmount + 50))`
         - Home: set to 0
         - End: set to maxWager
       - Add `aria-label="Wager amount"`, `aria-valuemin={0}`, `aria-valuemax={maxWager}`, `aria-valuenow={wagerAmount}`, `aria-valuetext={\`${wagerAmount} points\`}` to the range input (some already exist, verify and add missing ones)
       - Add `role="group"` with `aria-labelledby` to the outcome preview section

    4. Update `ResultsScreen.tsx` for accordion keyboard navigation:
       - Each question accordion button already works with Enter (it's a button element)
       - Add `onKeyDown` handler to the accordion buttons:
         - ArrowDown: focus next accordion button
         - ArrowUp: focus previous accordion button
       - Use ref array pattern to manage focus between accordion buttons
       - Add `aria-expanded={isExpanded}` to each accordion button
       - Add `aria-controls={\`question-detail-${index}\`}` to button and `id={\`question-detail-${index}\`}` to expanded content div
  </action>
  <verify>
    Run `cd frontend && npm run build` to verify compilation. Check that AnswerGrid has onKeyDown handlers, WagerScreen has PageUp/PageDown support, and ResultsScreen has aria-expanded attributes.
  </verify>
  <done>
    Arrow keys navigate between answer options with roving tabindex. Enter/Space locks in selected answer. Number keys 1-4 directly select answers. Wager slider supports PageUp/PageDown for 50-point jumps and Home/End. Results screen accordions navigable with Up/Down arrows and have proper aria-expanded/aria-controls attributes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Pause overlay with Escape key and focus trap</name>
  <files>
    frontend/src/features/game/components/PauseOverlay.tsx
    frontend/src/features/game/components/GameScreen.tsx
    frontend/src/features/game/gameReducer.ts
    frontend/src/types/game.ts
  </files>
  <action>
    1. Create `frontend/src/features/game/components/PauseOverlay.tsx`:
       - Import FocusTrap from 'focus-trap-react'
       - Import motion, AnimatePresence from 'framer-motion'
       - Props: `{ onResume: () => void; onQuit: () => void }`
       - Render a full-screen dark overlay (bg-black/80 backdrop-blur-sm) with:
         - Large "PAUSED" text (text-4xl font-bold text-white)
         - Question text is NOT shown (hidden to prevent extra reading time - this is the overlay itself, question is behind it)
         - Two buttons: "Resume" (teal bg, primary action) and "Quit Game" (transparent with border)
         - Resume button gets auto-focus via FocusTrap initialFocus
       - Wrap content in FocusTrap:
         ```tsx
         <FocusTrap focusTrapOptions={{
           initialFocus: '#resume-button',
           escapeDeactivates: false, // Escape already handled by parent
           returnFocusOnDeactivate: true,
         }}>
         ```
       - Add `role="dialog"` and `aria-modal="true"` and `aria-label="Game paused"` to the overlay container
       - Fade in/out with AnimatePresence

    2. Update `frontend/src/types/game.ts`:
       - No changes needed - `isTimerPaused` already exists on GameState

    3. Update `frontend/src/features/game/gameReducer.ts`:
       - Add new action types:
         - `{ type: 'PAUSE_GAME' }` - sets isTimerPaused to true, adds a new `isPaused: boolean` field
         - `{ type: 'RESUME_GAME' }` - sets isTimerPaused to false, sets isPaused to false
       - Actually, simpler: just use existing `isTimerPaused` and manage pause state in GameScreen with local useState. The reducer already has isTimerPaused. We need a PAUSE_GAME action that sets isTimerPaused: true, and RESUME_GAME that sets isTimerPaused: false.
       - Add to GameAction type: `| { type: 'PAUSE_GAME' } | { type: 'RESUME_GAME' }`
       - Add cases:
         - PAUSE_GAME: only valid during 'answering' or 'selected' phases (when timer is running). Sets `isTimerPaused: true`.
         - RESUME_GAME: sets `isTimerPaused: false`.
       - Also need to track isPaused separately from isTimerPaused because isTimerPaused is also set during lock/reveal. Add `isPaused: boolean` to GameState type and initialGameState (default false).
       - PAUSE_GAME sets both `isTimerPaused: true` and `isPaused: true`
       - RESUME_GAME sets both `isTimerPaused: false` and `isPaused: false`
       - Update `frontend/src/types/game.ts` to add `isPaused: boolean` to GameState

    4. Update `frontend/src/features/game/components/GameScreen.tsx`:
       - Add Escape key handler via useEffect + window.addEventListener('keydown'):
         - When Escape pressed during gameplay (answering or selected phase, NOT during reveal, NOT during wager, NOT during pause overlay):
           - If not paused: dispatch PAUSE_GAME, call `announce.polite('Game paused')`
           - If paused: do nothing (Resume button handles unpause)
         - When Escape pressed while Learn More modal is open: close the modal (already handled by headlessui)
         - When Escape pressed while quit dialog is open: cancel the dialog
       - Import announce from '../../utils/announce' (adjust path as needed)
       - Render PauseOverlay when `state.isPaused` is true:
         ```tsx
         {state.isPaused && (
           <PauseOverlay
             onResume={() => {
               dispatch({ type: 'RESUME_GAME' });
               announce.polite('Game resumed');
             }}
             onQuit={handleQuit}
           />
         )}
         ```
         Wait - GameScreen doesn't have direct access to dispatch. It receives actions as props from Game.tsx.
       - Alternative: Add `pauseGame: () => void` and `resumeGame: () => void` to useGameState hook and pass as props to GameScreen.
       - Update `frontend/src/features/game/hooks/useGameState.ts`:
         - Add `pauseGame` function: `dispatch({ type: 'PAUSE_GAME' })`
         - Add `resumeGame` function: `dispatch({ type: 'RESUME_GAME' })`
         - Return both from the hook
       - Update GameScreen props to receive `pauseGame` and `resumeGame`
       - Update Game.tsx to pass these props from useGameState
  </action>
  <verify>
    Run `cd frontend && npm run build` to verify compilation. Check that PauseOverlay renders with focus trap, GameScreen handles Escape key, and gameReducer has PAUSE_GAME/RESUME_GAME actions.
  </verify>
  <done>
    Escape key pauses game timer during answering/selected phases. Pause overlay appears with dark backdrop hiding question text. Focus is trapped within pause overlay (Resume and Quit buttons). Resume button resumes timer. Quit navigates to home. Screen reader announces "Game paused" and "Game resumed". isPaused state tracked separately from isTimerPaused to distinguish pause overlay from other timer pauses.
  </done>
</task>

<task type="auto">
  <name>Task 3: Screen reader announcements for game events</name>
  <files>
    frontend/src/features/game/components/GameTimer.tsx
    frontend/src/features/game/components/GameScreen.tsx
    frontend/src/features/game/components/AnswerGrid.tsx
    frontend/src/pages/Game.tsx
  </files>
  <action>
    1. Update `GameTimer.tsx` for timer threshold announcements:
       - Import `announce` from '../../../utils/announce' (or correct relative path from features/game/components/)
       - Inside the render callback of CountdownCircleTimer, add a useEffect (or within the existing render function):
         - When remainingTime === 10: `announce.polite('10 seconds remaining')`
         - When remainingTime === 5: `announce.polite('5 seconds remaining')`
         - When remainingTime === 0: `announce.assertive("Time's up")`
       - IMPORTANT: The render callback re-runs on every tick. Use a ref to track the last announced threshold to avoid re-announcing.
       - Actually, since the render prop re-runs frequently, better to lift announcement logic outside. The GameTimer already has onTimeUpdate callback that reports remaining time to parent. Move announcement logic to GameScreen.tsx where onTimeUpdate is handled via setCurrentTimeRemaining.
       - Better approach in GameScreen.tsx: Add a useEffect watching `currentTimeRemaining`:
         ```ts
         useEffect(() => {
           if (state.phase !== 'answering' && state.phase !== 'selected') return;
           if (currentTimeRemaining === 10) announce.polite('10 seconds remaining');
           else if (currentTimeRemaining === 5) announce.polite('5 seconds remaining');
         }, [currentTimeRemaining, state.phase]);
         ```
       - The "Time's up" announcement happens when timeout occurs - add to the onTimeout handler.

    2. Update `GameScreen.tsx` for answer reveal announcements:
       - Import `announce` from utils/announce
       - When entering 'revealing' phase (useEffect watching state.phase and state.answers.length):
         - Get the latest answer from state.answers
         - Get the current question for option text
         - Build announcement:
           - If correct: `"Correct! The answer is ${OPTION_LETTERS[correctAnswer]}, ${question.options[correctAnswer]}. You earned ${latestAnswer.totalPoints} points."`
           - If wrong (selectedOption !== null): `"Not quite. The correct answer was ${OPTION_LETTERS[correctAnswer]}, ${question.options[correctAnswer]}."`
           - If timeout (selectedOption === null): `"Time's up. The correct answer was ${OPTION_LETTERS[correctAnswer]}, ${question.options[correctAnswer]}."`
         - Call `announce.polite(message)` (polite, not assertive, to not interrupt other reading)
       - Use OPTION_LETTERS = ['A', 'B', 'C', 'D'] for the letter prefix

    3. Update `GameScreen.tsx` for question number announcements:
       - User decision: announce only at start ("Question 1 of 10") and final ("Final Question"), NOT every transition
       - When state.currentQuestionIndex === 0 and phase === 'answering' (first question):
         `announce.polite('Question 1 of 10')`
       - When isFinalQuestion and phase === 'answering':
         `announce.assertive('Final Question')` (assertive for emphasis)
       - Add these to the existing useEffect that handles question changes or create a new one

    4. Update `Game.tsx` for results screen announcement:
       - When phase transitions to 'complete':
         `announce.polite('Game complete. Your score is ${gameResult.totalScore} points with ${gameResult.totalCorrect} out of ${gameResult.totalQuestions} correct.')`
       - Add a useEffect watching state.phase === 'complete'
  </action>
  <verify>
    Run `cd frontend && npm run build` to verify compilation. Check that announce.polite/assertive calls are placed at all specified trigger points in GameScreen, GameTimer area, and Game.tsx.
  </verify>
  <done>
    Screen reader announces timer at 10s, 5s remaining and "Time's up" at 0. Answer reveal announces result + correct answer + points. Question 1 announces "Question 1 of 10". Final question announces "Final Question". Game completion announces total score and accuracy. All announcements use polite mode except "Time's up" (assertive) and "Final Question" (assertive).
  </done>
</task>

</tasks>

<verification>
- `cd frontend && npm run build` succeeds
- AnswerGrid has onKeyDown with ArrowUp/ArrowDown/Enter/Space/'1'-'4' handlers
- PauseOverlay.tsx exists with FocusTrap and dark overlay
- gameReducer has PAUSE_GAME and RESUME_GAME actions
- GameScreen handles Escape key to toggle pause
- WagerScreen range input has PageUp/PageDown support
- ResultsScreen accordions have aria-expanded and keyboard nav
- announce.polite/assertive called at: timer thresholds, answer reveal, Q1, final Q, game complete
</verification>

<success_criteria>
- All interactive elements keyboard navigable without mouse
- Arrow keys + Enter/Space navigate and select answers
- Number keys 1-4 directly select corresponding answers
- Escape pauses game, shows overlay hiding question, traps focus
- Resume and Quit buttons work from pause overlay
- Wager slider: Arrow keys (10pt), PageUp/Down (50pt), Home/End
- Results accordions: Up/Down arrows move between questions, Enter/Space toggles
- Timer announces at 10s, 5s, 0s thresholds
- Answer reveal announced with result, correct answer, and points
- First and final questions specifically announced
- Game completion announced with score summary
</success_criteria>

<output>
After completion, create `.planning/phases/07-polish-performance/07-03-SUMMARY.md`
</output>
