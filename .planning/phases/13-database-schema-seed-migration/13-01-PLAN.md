---
phase: 13-database-schema-seed-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/db/schema.ts
  - backend/src/db/migrations/0001_create_collections_topics_questions.sql
  - backend/src/db/migrations/meta/_journal.json
  - backend/drizzle.config.ts
  - backend/rollback.sql
  - backend/package.json
autonomous: true

must_haves:
  truths:
    - "PostgreSQL contains collections, topics, collection_topics, questions, and collection_questions tables with correct schema"
    - "Each collection can define its own topic categories via collection_topics junction table"
    - "Questions have an optional expires_at field"
    - "Learning content stored as JSONB column"
    - "Migration is reversible via rollback script"
  artifacts:
    - path: "backend/src/db/schema.ts"
      provides: "Drizzle ORM table definitions for all 5 tables"
      contains: "collections|topics|collectionTopics|questions|collectionQuestions"
    - path: "backend/src/db/migrations/0001_create_collections_topics_questions.sql"
      provides: "Forward migration SQL"
      contains: "CREATE TABLE"
    - path: "backend/rollback.sql"
      provides: "Reverse migration SQL"
      contains: "DROP TABLE"
    - path: "backend/drizzle.config.ts"
      provides: "Drizzle Kit configuration"
      contains: "schemaFilter.*civic_trivia"
  key_links:
    - from: "backend/src/db/schema.ts"
      to: "backend/src/db/migrations/0001_*.sql"
      via: "drizzle-kit generate"
      pattern: "CREATE TABLE civic_trivia"
    - from: "backend/drizzle.config.ts"
      to: "backend/src/db/schema.ts"
      via: "schema config path"
      pattern: "schema.*src/db/schema"
---

<objective>
Create the PostgreSQL schema for the collections data model using Drizzle ORM.

Purpose: This is the database foundation that every downstream v1.2 feature depends on. The schema defines collections, topics, questions, and their many-to-many relationships via junction tables.

Output: Drizzle schema definitions, generated SQL migration, rollback script, and Drizzle Kit configuration. The migration will be run against the Supabase database.
</objective>

<execution_context>
@C:\Users\Chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-database-schema-seed-migration/13-CONTEXT.md
@.planning/phases/13-database-schema-seed-migration/13-RESEARCH.md
@backend/src/config/database.ts
@backend/schema.sql
@backend/package.json
@backend/tsconfig.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Drizzle ORM and create schema definitions</name>
  <files>
    backend/package.json
    backend/src/db/schema.ts
    backend/drizzle.config.ts
  </files>
  <action>
Install Drizzle ORM and Drizzle Kit:
```bash
cd backend && npm install drizzle-orm && npm install -D drizzle-kit
```

Create `backend/drizzle.config.ts` with:
- schema path: `./src/db/schema.ts`
- out path: `./src/db/migrations`
- dialect: `postgresql`
- dbCredentials using `process.env.DATABASE_URL`
- schemaFilter: `['civic_trivia']`
- verbose: true, strict: true

Create `backend/src/db/schema.ts` with Drizzle table definitions for all 5 tables in the `civic_trivia` schema. Use `pgSchema('civic_trivia')` to scope all tables.

**collections table:**
- id: serial primary key
- name: text, not null
- slug: text, not null, unique
- description: text, not null
- localeCode: text('locale_code'), not null
- localeName: text('locale_name'), not null
- iconIdentifier: text('icon_identifier'), not null
- themeColor: text('theme_color'), not null (7-char hex like '#1E3A8A')
- isActive: boolean('is_active'), not null, default false
- sortOrder: integer('sort_order'), not null
- createdAt: timestamp('created_at', { withTimezone: true }), defaultNow(), not null
- updatedAt: timestamp('updated_at', { withTimezone: true }), defaultNow(), not null
- Indexes: slug (unique already handles this), partial index on (is_active, sort_order) WHERE is_active = true

**topics table:**
- id: serial primary key
- name: text, not null (display name like "Constitution")
- slug: text, not null, unique (like "constitution")
- description: text, nullable
- createdAt: timestamp('created_at', { withTimezone: true }), defaultNow(), not null
- Index on slug

**collection_topics junction table:**
- collectionId: integer('collection_id'), FK -> collections.id, onDelete cascade
- topicId: integer('topic_id'), FK -> topics.id, onDelete cascade
- createdAt: timestamp, defaultNow()
- Composite primary key on (collectionId, topicId)
- Indexes on both FK columns

**questions table:**
- id: serial primary key
- externalId: text('external_id'), not null, unique (preserves the "q001" style IDs from JSON)
- text: text, not null
- options: jsonb('options'), not null (array of 4 strings — use jsonb not text[] for consistency)
- correctAnswer: integer('correct_answer'), not null (0-based index)
- explanation: text, not null
- difficulty: text, not null (CHECK constraint: 'easy', 'medium', 'hard')
- topicId: integer('topic_id'), FK -> topics.id, not null
- subcategory: text, nullable (stores the topicCategory value like 'bill-of-rights', 'federalism')
- source: jsonb('source'), not null (object with name and url — required for ALL questions per CONTEXT.md)
- learningContent: jsonb('learning_content'), nullable (paragraphs array + corrections object, WITHOUT the nested source/topic — those are promoted to columns)
- expiresAt: timestamp('expires_at', { withTimezone: true }), nullable
- createdAt: timestamp('created_at', { withTimezone: true }), defaultNow(), not null
- updatedAt: timestamp('updated_at', { withTimezone: true }), defaultNow(), not null
- Indexes: topicId FK index, GIN index on learning_content with jsonb_path_ops, index on external_id (unique already), partial index on expires_at WHERE expires_at IS NOT NULL

IMPORTANT design note on `source` column: The CONTEXT.md says "Source URL/name is a required field for ALL questions." This means source is a top-level NOT NULL jsonb column on questions (not buried inside learningContent). The learningContent JSONB stores only paragraphs and corrections (the optional deep-dive content). This separation means questions can have authoritative sources even without learning content.

**collection_questions junction table:**
- collectionId: integer('collection_id'), FK -> collections.id, onDelete cascade
- questionId: integer('question_id'), FK -> questions.id, onDelete cascade
- createdAt: timestamp, defaultNow()
- Composite primary key on (collectionId, questionId)
- Indexes on both FK columns

Export all table definitions and inferred types using `typeof table.$inferSelect` and `typeof table.$inferInsert` patterns for each table.
  </action>
  <verify>
Run `cd backend && npx tsc --noEmit` — schema.ts compiles with no TypeScript errors.
Run `cd backend && npx drizzle-kit generate` — produces SQL migration file in src/db/migrations/.
Inspect the generated SQL to confirm all 5 tables, indexes, and constraints are present.
  </verify>
  <done>
- schema.ts defines 5 tables (collections, topics, collection_topics, questions, collection_questions) with correct columns, types, and constraints
- drizzle.config.ts configured for civic_trivia schema
- Drizzle Kit generates migration SQL successfully
- TypeScript types exported for all tables
  </done>
</task>

<task type="auto">
  <name>Task 2: Run migration against database and create rollback script</name>
  <files>
    backend/src/db/migrations/0001_create_collections_topics_questions.sql
    backend/rollback.sql
    backend/package.json
  </files>
  <action>
First, review the generated migration SQL from Task 1. If Drizzle Kit generated it correctly, use it as-is. If it needs adjustments (e.g., missing CHECK constraint on difficulty, missing civic_trivia schema prefix), manually edit the SQL file.

Ensure the migration SQL includes:
1. All 5 tables created in civic_trivia schema
2. CHECK constraint on questions.difficulty: `CHECK (difficulty IN ('easy', 'medium', 'hard'))`
3. CHECK constraint on questions.correct_answer: `CHECK (correct_answer >= 0 AND correct_answer <= 3)`
4. All indexes as specified in schema.ts
5. Foreign key constraints with ON DELETE CASCADE

Add npm scripts to backend/package.json:
```json
"db:generate": "drizzle-kit generate",
"db:migrate": "drizzle-kit push",
"db:seed": "tsx src/db/seed/seed.ts"
```

Run the migration against the Supabase database:
```bash
cd backend && npx drizzle-kit push
```

This will push the schema directly to the database. Drizzle Kit's `push` command applies schema changes without needing a migration runner.

Create `backend/rollback.sql` with DROP statements in reverse dependency order:
```sql
-- Rollback: Phase 13 Database Schema
-- Run this to revert all Phase 13 schema changes
-- WARNING: This will DELETE all collection and question data

DROP TABLE IF EXISTS civic_trivia.collection_questions CASCADE;
DROP TABLE IF EXISTS civic_trivia.questions CASCADE;
DROP TABLE IF EXISTS civic_trivia.collection_topics CASCADE;
DROP TABLE IF EXISTS civic_trivia.topics CASCADE;
DROP TABLE IF EXISTS civic_trivia.collections CASCADE;
```

After migration, verify tables exist by connecting to the database and listing tables in the civic_trivia schema.
  </action>
  <verify>
Run a quick query to confirm tables exist:
```bash
cd backend && node -e "
import('pg').then(({default: pg}) => {
  const pool = new pg.Pool({ connectionString: process.env.DATABASE_URL, ssl: { rejectUnauthorized: false }, options: '-c search_path=civic_trivia' });
  pool.query(\"SELECT table_name FROM information_schema.tables WHERE table_schema = 'civic_trivia' ORDER BY table_name\")
    .then(r => { console.log('Tables:', r.rows.map(r => r.table_name)); pool.end(); })
    .catch(e => { console.error(e); pool.end(); });
})
"
```
Expected output should include: collection_questions, collection_topics, collections, questions, topics (plus the existing users table).
  </verify>
  <done>
- All 5 new tables exist in civic_trivia schema on Supabase
- CHECK constraints active on questions.difficulty and questions.correct_answer
- All indexes created
- rollback.sql can cleanly drop all Phase 13 tables
- npm scripts added for db:generate, db:migrate, db:seed
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes in backend directory (schema compiles)
2. All 5 tables exist in civic_trivia schema: collections, topics, collection_topics, questions, collection_questions
3. `\d civic_trivia.questions` shows correct columns including source (jsonb, NOT NULL), learning_content (jsonb, nullable), expires_at (timestamptz, nullable)
4. `\d civic_trivia.collections` shows is_active, sort_order, locale fields
5. Junction tables have composite primary keys
6. rollback.sql exists and contains DROP statements
</verification>

<success_criteria>
- PostgreSQL contains all 5 tables with correct schema, constraints, and indexes
- Drizzle schema.ts compiles and exports typed table definitions
- Migration is reversible via rollback.sql
- Tables are empty and ready for seeding
</success_criteria>

<output>
After completion, create `.planning/phases/13-database-schema-seed-migration/13-01-SUMMARY.md`
</output>
