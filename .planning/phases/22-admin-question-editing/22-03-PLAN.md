---
phase: 22-admin-question-editing
plan: 03
type: execute
wave: 2
depends_on: ["22-01", "22-02"]
files_modified:
  - frontend/src/pages/admin/components/QuestionDetailPanel.tsx
  - frontend/src/pages/admin/components/QualityComparisonModal.tsx
  - frontend/src/pages/admin/QuestionsPage.tsx
autonomous: false

must_haves:
  truths:
    - "Admin can click Edit button in panel header to toggle into edit mode"
    - "Admin can modify question text, options, explanation, source URL, and difficulty in edit mode"
    - "Saving calls PUT /api/admin/questions/:id and shows quality comparison modal with before/after scores"
    - "After save, the question table row updates in-place without full page reload"
    - "Admin can archive a question from the detail panel footer"
    - "Unsaved changes trigger confirmation dialog when closing panel or navigating away"
    - "Cancel button returns to view mode without saving"
  artifacts:
    - path: "frontend/src/pages/admin/components/QuestionDetailPanel.tsx"
      provides: "Extended panel with edit mode toggle, save/cancel, archive button, unsaved changes guard"
      contains: "isEditMode"
    - path: "frontend/src/pages/admin/components/QualityComparisonModal.tsx"
      provides: "Modal showing before/after quality score and violations comparison"
      contains: "QualityComparisonModal"
    - path: "frontend/src/pages/admin/QuestionsPage.tsx"
      provides: "Updated page with onQuestionUpdated callback for optimistic table row update"
      contains: "onQuestionUpdated"
  key_links:
    - from: "frontend/src/pages/admin/components/QuestionDetailPanel.tsx"
      to: "frontend/src/pages/admin/components/QuestionEditForm.tsx"
      via: "conditional render based on isEditMode"
      pattern: "isEditMode.*QuestionEditForm"
    - from: "frontend/src/pages/admin/components/QuestionDetailPanel.tsx"
      to: "PUT /api/admin/questions/:id"
      via: "fetch call on save"
      pattern: "fetch.*method.*PUT"
    - from: "frontend/src/pages/admin/QuestionsPage.tsx"
      to: "frontend/src/pages/admin/components/QuestionDetailPanel.tsx"
      via: "onQuestionUpdated prop"
      pattern: "onQuestionUpdated"
---

<objective>
Wire the edit form into the detail panel, add the quality comparison modal, implement optimistic table row updates, archive action, and unsaved changes protection.

Purpose: This plan connects all the pieces — the backend PUT endpoint (Plan 01), the edit form components (Plan 02), and the existing detail panel and questions page. After this plan, admins can edit questions end-to-end.

Output: Extended QuestionDetailPanel with edit mode, new QualityComparisonModal, updated QuestionsPage with optimistic row updates, archive action, and unsaved changes warning.
</objective>

<execution_context>
@C:\Users\Chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-admin-question-editing/22-RESEARCH.md
@.planning/phases/22-admin-question-editing/22-01-SUMMARY.md
@.planning/phases/22-admin-question-editing/22-02-SUMMARY.md

@frontend/src/pages/admin/components/QuestionDetailPanel.tsx
@frontend/src/pages/admin/components/QuestionEditForm.tsx
@frontend/src/pages/admin/QuestionsPage.tsx
@frontend/src/pages/admin/components/QuestionTable.tsx
@backend/src/routes/admin.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create QualityComparisonModal and extend QuestionDetailPanel with edit mode</name>
  <files>
    frontend/src/pages/admin/components/QualityComparisonModal.tsx
    frontend/src/pages/admin/components/QuestionDetailPanel.tsx
  </files>
  <action>
**QualityComparisonModal.tsx** — A Headless UI Dialog that shows before/after quality comparison:

Define `QualityDelta` interface:
```typescript
interface QualityDelta {
  oldScore: number | null;
  newScore: number;
  oldViolations: number;
  newViolations: number;
  violations: Array<{
    rule: string;
    severity: 'blocking' | 'advisory';
    message: string;
    evidence?: string;
  }>;
}
```

Props: `{ isOpen: boolean, onClose: () => void, delta: QualityDelta | null }`

Implementation:
- Use `<Dialog>` and `<Transition>` from @headlessui/react (same pattern as QuestionDetailPanel)
- Centered modal (not slide-over) with max-w-md
- Header: "Quality Re-Scoring Complete" with a subtle divider
- Score comparison section:
  - Old score (gray, large text) arrow-right-icon New score (colored: green if improved, red if worse, gray if same)
  - Show delta as "(+N)" or "(-N)" next to new score, colored appropriately
  - If old score was null, show "N/A" for old
- Violations comparison section (only shown if violations count changed):
  - Old count arrow-right New count, same color coding
- Current violations list (only if violations exist):
  - Each violation as a row with severity badge (blocking=red, advisory=yellow) and message
- Footer: Single "Close" button (red-600 bg, matching admin theme)

Export `QualityComparisonModal` and `QualityDelta` type.

**QuestionDetailPanel.tsx** — Extend the existing panel with edit mode:

1. **Add new props** to `QuestionDetailPanelProps`:
   - `onQuestionUpdated?: (updatedQuestion: UpdatedQuestionData) => void` — Callback to update the table row

   Define `UpdatedQuestionData` type that matches what the table needs:
   ```typescript
   interface UpdatedQuestionData {
     id: number;
     text: string;
     difficulty: string;
     qualityScore: number | null;
     violationCount: number;
     status: string;
   }
   ```

2. **Add edit mode state**:
   - `isEditMode: boolean` — Initially false
   - `hasUnsavedChanges: boolean` — Tracked via onDirtyChange callback from QuestionEditForm
   - `isSaving: boolean` — Loading state during save
   - `qualityDelta: QualityDelta | null` — For the comparison modal
   - `showQualityModal: boolean` — Controls QualityComparisonModal visibility

3. **Reset edit mode when questionId changes** — In the existing useEffect that fetches question detail, add: `setIsEditMode(false)`, `setHasUnsavedChanges(false)`, `setIsSaving(false)`.

4. **Handle close with unsaved changes** — Create a `handleClose` function that:
   - If `hasUnsavedChanges`, show `window.confirm('You have unsaved changes. Discard changes?')`
   - If user confirms, reset edit mode and call original `onClose`
   - If user cancels, do nothing (stay in edit mode)
   - Pass `handleClose` to the Dialog's `onClose` prop AND the close button onClick (replacing the direct `onClose` reference)

5. **useBlocker for React Router navigation** — Import `useBlocker` from 'react-router-dom'. Call `useBlocker(({ currentLocation, nextLocation }) => hasUnsavedChanges && currentLocation.pathname !== nextLocation.pathname)`. Handle the blocked state: when `blocker.state === 'blocked'`, use `window.confirm()` to ask, then `blocker.proceed()` or `blocker.reset()`.

6. **beforeunload handler** — Add a useEffect that adds `beforeunload` listener when `hasUnsavedChanges` is true and removes it when false. Prevents browser close/reload from losing edits.

7. **Update the panel header**:
   - When NOT in edit mode: Add an "Edit" button next to the navigation arrows. Style: `px-3 py-1.5 text-sm font-medium text-white bg-red-700 hover:bg-red-600 rounded`. Only show if question is loaded and not in loading state.
   - When IN edit mode: Replace the "Edit" button with "Save" and "Cancel" buttons.
     - Save: `px-3 py-1.5 text-sm font-medium text-white bg-green-600 hover:bg-green-500 rounded disabled:opacity-50`. Disabled when `isSaving`. Shows "Saving..." text when saving.
     - Cancel: `px-3 py-1.5 text-sm font-medium text-white bg-gray-600 hover:bg-gray-500 rounded`. Disabled when `isSaving`.
   - Hide prev/next navigation buttons when in edit mode (prevent navigating away mid-edit).

8. **Conditional body rendering**:
   - When `isEditMode` is true AND `questionDetail` exists: render `<QuestionEditForm question={questionDetail} onSave={handleSave} onCancel={handleCancel} onDirtyChange={setHasUnsavedChanges} isSaving={isSaving} />`
   - When `isEditMode` is false: render the existing view-mode content (the current body content)

9. **handleSave function**:
   a. Set `isSaving(true)`
   b. Call `fetch(\`${API_URL}/api/admin/questions/${questionId}\`, { method: 'PUT', headers: { 'Content-Type': 'application/json', Authorization: \`Bearer ${accessToken}\` }, body: JSON.stringify(formData) })`
   c. On success (200): Parse response as `{ question, qualityDelta }`
   d. Update the local `questionDetail` state with the new question data (re-map like the fetch does)
   e. Set `qualityDelta` state and `showQualityModal(true)`
   f. Call `onQuestionUpdated` with the updated data for the table row
   g. Set `isEditMode(false)`, `hasUnsavedChanges(false)`
   h. On failure: Show error (set `error` state or alert)
   i. Finally: Set `isSaving(false)`

10. **handleCancel function**:
    - If `hasUnsavedChanges`, show `window.confirm('Discard changes?')`
    - If confirmed (or no changes), `setIsEditMode(false)`, `setHasUnsavedChanges(false)`

11. **Archive button** — Add an archive section at the bottom of the panel body (below the Quality Assessment section), visible ONLY in view mode and when question status is NOT 'archived':
    - Red border-top separator
    - "Archive Question" button: `px-4 py-2 text-sm font-medium text-red-700 bg-red-50 border border-red-300 hover:bg-red-100 rounded-md`
    - On click: `window.confirm('Are you sure you want to archive this question? It will be removed from active rotation.')` then call `POST /api/admin/questions/${questionId}/archive`
    - On success: update `questionDetail.status` to 'archived', call `onQuestionUpdated` with updated status

12. **Render QualityComparisonModal** — At the bottom of the component (outside the main Dialog but inside the component return), render: `<QualityComparisonModal isOpen={showQualityModal} onClose={() => setShowQualityModal(false)} delta={qualityDelta} />`

Import QuestionEditForm and EditFormData from './QuestionEditForm'.
Import QualityComparisonModal and QualityDelta from './QualityComparisonModal'.
  </action>
  <verify>
Run `cd frontend && npx tsc --noEmit` to verify TypeScript compilation succeeds.

Verify QuestionDetailPanel.tsx contains:
- `isEditMode` state variable
- `useBlocker` import and usage
- Conditional rendering of QuestionEditForm vs view mode
- handleSave function that calls PUT endpoint
- Archive button section
- QualityComparisonModal rendered
  </verify>
  <done>
QuestionDetailPanel toggles between view and edit mode. Save calls PUT API and shows quality comparison modal. Archive button works from panel footer. Unsaved changes are guarded by useBlocker + beforeunload + close confirmation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update QuestionsPage with onQuestionUpdated callback for optimistic table row update</name>
  <files>frontend/src/pages/admin/QuestionsPage.tsx</files>
  <action>
1. **Add onQuestionUpdated handler** — Create a `handleQuestionUpdated` function that receives the updated question data and updates the questions array in state:
   ```typescript
   const handleQuestionUpdated = (updated: { id: number; text: string; difficulty: string; qualityScore: number | null; violationCount: number; status: string }) => {
     setQuestions(prev => {
       if (!prev) return prev;
       return prev.map(q => {
         if (q.id !== updated.id) return q;
         return {
           ...q,
           text: updated.text.length > 120 ? updated.text.substring(0, 120) + '...' : updated.text,
           difficulty: updated.difficulty,
           qualityScore: updated.qualityScore,
           violationCount: updated.violationCount,
           status: updated.status,
         };
       });
     });
   };
   ```
   Note: Truncate text to 120 chars to match the server-side truncation in the explore endpoint.

2. **Pass callback to QuestionDetailPanel** — Add the `onQuestionUpdated` prop:
   ```tsx
   <QuestionDetailPanel
     questionId={selectedQuestionId}
     onClose={handlePanelClose}
     onNavigate={handlePanelNavigate}
     hasPrev={selectedQuestionIndex > 0}
     hasNext={questions ? selectedQuestionIndex < questions.length - 1 : false}
     onQuestionUpdated={handleQuestionUpdated}
   />
   ```

3. **Handle archived question removal** — If the updated question has `status: 'archived'` and the current status filter is NOT 'archived', optionally remove the question from the visible list. However, for simplicity and to avoid confusion, keep the row visible with updated status badge — the admin can see the change immediately. The row will disappear on next filter/page change.

This is a small change — the main work is in Task 1. The key link is the `onQuestionUpdated` callback prop flowing from QuestionsPage through QuestionDetailPanel.
  </action>
  <verify>
Run `cd frontend && npx tsc --noEmit` to verify TypeScript compilation.

Verify QuestionsPage.tsx contains:
- `handleQuestionUpdated` function
- `onQuestionUpdated={handleQuestionUpdated}` prop on QuestionDetailPanel
  </verify>
  <done>
QuestionsPage passes onQuestionUpdated callback to QuestionDetailPanel. After save, the table row updates in-place with new text, difficulty, qualityScore, violationCount, and status — no full page reload needed.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete admin question editing flow: edit mode in detail panel, drag-and-drop option reordering, quality re-scoring on save with before/after comparison, optimistic table row update, archive action, and unsaved changes protection.
  </what-built>
  <how-to-verify>
1. Start the dev servers: `cd backend && npm run dev` and `cd frontend && npm run dev`
2. Log in as an admin user
3. Navigate to the Question Explorer (/admin/questions/explore)
4. Click on any question row to open the detail panel
5. Click "Edit" button in the panel header — form inputs should appear
6. Verify all fields are editable: question text, 4 options, explanation, source URL, difficulty slider
7. Try dragging an option to reorder — the correct answer radio should follow the option
8. Modify the question text and check the character counter updates
9. Click "Cancel" — if changes were made, confirmation dialog should appear
10. Click "Edit" again, make a change, then click "Save"
11. Verify the quality comparison modal appears showing before/after scores
12. Close the modal — verify the table row behind the panel reflects the changes
13. Open a question and click "Archive Question" — confirm the archival works
14. Try editing a question, then click the X to close the panel — unsaved changes warning should appear
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues</resume-signal>
</task>

</tasks>

<verification>
- `cd frontend && npx tsc --noEmit` passes
- QuestionDetailPanel has edit mode toggle, save/cancel buttons, archive button
- QuestionEditForm renders inside panel when isEditMode is true
- QualityComparisonModal shows after successful save
- QuestionsPage updates table row optimistically via onQuestionUpdated callback
- useBlocker guards against React Router navigation with unsaved changes
- beforeunload guards against browser close with unsaved changes
- Archive action calls POST /questions/:id/archive and updates panel + table
</verification>

<success_criteria>
Admin can edit a question end-to-end: click Edit, modify fields (including drag-and-drop option reorder), save, see quality re-scoring comparison, and observe the table row update without page reload. Admin can also archive questions from the detail panel. All unsaved changes are protected.
</success_criteria>

<output>
After completion, create `.planning/phases/22-admin-question-editing/22-03-SUMMARY.md`
</output>
