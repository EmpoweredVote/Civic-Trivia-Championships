---
phase: 22-admin-question-editing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/routes/admin.ts
autonomous: true

must_haves:
  truths:
    - "PUT /api/admin/questions/:id accepts edited question fields and returns updated question with quality delta"
    - "Zod validates all input fields before any database write"
    - "Quality rules re-run after save and quality_score + violation_count update in DB"
    - "PATCH /api/admin/questions/:id/archive works from the detail panel (already exists but verify)"
    - "Difficulty is accepted as numeric 1-10 from admin, converted to easy/medium/hard for storage"
  artifacts:
    - path: "backend/src/routes/admin.ts"
      provides: "PUT /questions/:id endpoint with Zod validation, quality re-scoring, and delta response"
      contains: "router.put"
  key_links:
    - from: "backend/src/routes/admin.ts"
      to: "backend/src/services/qualityRules/index.ts"
      via: "auditQuestion import"
      pattern: "auditQuestion"
    - from: "backend/src/routes/admin.ts"
      to: "backend/src/db/schema.ts"
      via: "drizzle update query"
      pattern: "db\\.update\\(questions\\)"
---

<objective>
Create the backend PUT endpoint for editing questions with Zod validation and automatic quality re-scoring.

Purpose: The admin needs a backend API to save question edits. After saving, quality rules must re-run and the response must include before/after quality comparison data so the frontend can display it.

Output: PUT /api/admin/questions/:id endpoint in admin.ts that validates with Zod, updates the question, re-runs quality audit, updates quality_score and violation_count, and returns the updated question + quality delta.
</objective>

<execution_context>
@C:\Users\Chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@backend/src/routes/admin.ts
@backend/src/services/qualityRules/index.ts
@backend/src/services/qualityRules/types.ts
@backend/src/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add PUT /questions/:id endpoint with Zod validation and quality re-scoring</name>
  <files>backend/src/routes/admin.ts</files>
  <action>
Add a PUT endpoint to the admin router at `/questions/:id` that:

1. **Import Zod** — Add `import { z } from 'zod';` at the top of admin.ts. Zod is already in the backend package.json (used by Phase 19).

2. **Define UpdateQuestionSchema** — Create a Zod schema validating:
   - `text`: string, min 20, max 300
   - `options`: array of strings (each min 1 char, max 150), exactly length 4
   - `correctAnswer`: integer 0-3
   - `explanation`: string, min 30, max 500
   - `sourceUrl`: string, valid URL format (use `z.string().url()`)
   - `difficulty`: integer 1-10 (admin numeric scale)
   Use `.strict()` to reject unknown fields.

3. **Implement the PUT handler** — The handler should:
   a. Parse and validate `req.params.id` as integer
   b. Validate `req.body` with `UpdateQuestionSchema.safeParse()`
   c. On validation failure, return 400 with `{ error: 'Validation failed', details: [...] }` where details maps each error to `{ field, message }`
   d. Fetch the existing question from DB (return 404 if not found)
   e. Capture old `qualityScore` and `violationCount` for delta comparison
   f. Map numeric difficulty to string: 1-3 = 'easy', 4-7 = 'medium', 8-10 = 'hard'
   g. Update the question row using Drizzle `db.update(questions).set({...}).where(eq(questions.id, questionId))`. Update fields: text, options, correctAnswer, explanation, source (preserve existing source.name, update url from sourceUrl), difficulty (mapped string), updatedAt (new Date())
   h. Build a QuestionInput object from the updated fields and run `auditQuestion(questionInput, { skipUrlCheck: true })` — skip URL check for fast save response
   i. Update quality_score and violation_count columns from the audit result
   j. Fetch the fully updated question (with collection names via the same join pattern used in GET /questions/:id/detail)
   k. Return JSON: `{ question: updatedQuestion, qualityDelta: { oldScore, newScore, oldViolations, newViolations, violations: auditResult.violations } }`

4. **Place the PUT route** BEFORE the existing `router.get('/questions/explore', ...)` route to avoid Express route parameter conflicts (`:id` would match 'explore' if PUT is defined after).

5. **Verify the existing POST /questions/:id/archive endpoint** already works for archiving from the detail panel. It already exists in admin.ts — no changes needed, just confirm it returns appropriate data. The frontend will call this existing endpoint.

IMPORTANT: The source field in the DB is a jsonb object `{ name: string, url: string }`. When updating, preserve the existing `source.name` and only update `source.url` from the `sourceUrl` field in the request body.

IMPORTANT: Do NOT import Zod from 'zod/v4' or any subpath — use `import { z } from 'zod'` directly, matching the existing project pattern.
  </action>
  <verify>
Run `cd backend && npx tsc --noEmit` to verify TypeScript compilation succeeds with no errors.

Verify the route exists by searching for `router.put` in admin.ts.
  </verify>
  <done>
PUT /api/admin/questions/:id endpoint exists in admin.ts, validates input with Zod, updates the question in DB, re-runs quality audit, updates quality_score and violation_count, and returns updated question + qualityDelta object. TypeScript compiles clean.
  </done>
</task>

</tasks>

<verification>
- `cd backend && npx tsc --noEmit` passes (no TypeScript errors)
- admin.ts contains `router.put('/questions/:id'` with Zod validation, quality re-scoring, and delta response
- The UpdateQuestionSchema validates all 6 fields with appropriate constraints
- Difficulty mapping function converts 1-10 numeric to easy/medium/hard string
- Response includes `qualityDelta` with `oldScore`, `newScore`, `oldViolations`, `newViolations`, `violations`
</verification>

<success_criteria>
The backend has a PUT endpoint that accepts edited question data, validates it, persists changes, re-scores quality, and returns the delta — ready for the frontend to consume.
</success_criteria>

<output>
After completion, create `.planning/phases/22-admin-question-editing/22-01-SUMMARY.md`
</output>
