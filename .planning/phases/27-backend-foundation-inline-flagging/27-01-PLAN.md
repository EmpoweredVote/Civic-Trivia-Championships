---
phase: 27-backend-foundation-inline-flagging
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/db/schema.ts
  - backend/src/services/feedbackService.ts
  - backend/src/middleware/rateLimiter.ts
  - backend/src/routes/feedback.ts
  - backend/src/server.ts
autonomous: true

must_haves:
  truths:
    - "POST /api/feedback/flag creates a flag record in question_flags table"
    - "DELETE /api/feedback/flag/:questionId removes a flag record"
    - "Duplicate flag for same user+question returns 200 (idempotent, no error)"
    - "Un-flagging decrements flag_count on questions table"
    - "Rate limiter returns 429 after 10 flags in 15 minutes"
    - "Unauthenticated requests to flag endpoints return 401"
    - "Rate limiter does NOT apply to DELETE (un-flag) endpoint"
  artifacts:
    - path: "backend/src/db/schema.ts"
      provides: "questionFlags table definition with composite unique constraint, flag_count column on questions"
      contains: "questionFlags"
    - path: "backend/src/services/feedbackService.ts"
      provides: "createFlag and deleteFlag with transactional flag_count updates"
      exports: ["createFlag", "deleteFlag"]
    - path: "backend/src/middleware/rateLimiter.ts"
      provides: "Redis-based rolling window rate limiter"
      exports: ["flagRateLimiter"]
    - path: "backend/src/routes/feedback.ts"
      provides: "POST /flag and DELETE /flag/:questionId endpoints"
      exports: ["default"]
    - path: "backend/src/server.ts"
      provides: "Route registration for /api/feedback"
      contains: "feedbackRouter"
  key_links:
    - from: "backend/src/routes/feedback.ts"
      to: "backend/src/services/feedbackService.ts"
      via: "createFlag/deleteFlag function calls"
      pattern: "(createFlag|deleteFlag)\\("
    - from: "backend/src/routes/feedback.ts"
      to: "backend/src/middleware/rateLimiter.ts"
      via: "flagRateLimiter middleware on POST only"
      pattern: "flagRateLimiter"
    - from: "backend/src/services/feedbackService.ts"
      to: "backend/src/db/schema.ts"
      via: "Drizzle insert/delete on questionFlags + update flag_count on questions"
      pattern: "questionFlags|flagCount"
    - from: "backend/src/server.ts"
      to: "backend/src/routes/feedback.ts"
      via: "app.use('/api/feedback', feedbackRouter)"
      pattern: "feedbackRouter"
---

<objective>
Build the complete backend infrastructure for question flagging: database schema (question_flags table + flag_count denormalized column), feedback service with idempotent inserts and transactional flag count updates, Redis-based rate limiting middleware (10 flags per 15 minutes per user), and API endpoints (POST to create flag, DELETE to remove flag).

Purpose: Establishes the data persistence and API layer that the frontend flag button will call. Without this, flags have nowhere to go.
Output: Working API endpoints at /api/feedback/flag that persist flags to PostgreSQL with rate limiting via Redis.
</objective>

<execution_context>
@C:\Users\Chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/27-backend-foundation-inline-flagging/27-RESEARCH.md
@.planning/phases/27-backend-foundation-inline-flagging/27-CONTEXT.md

Key existing files to read before implementing:
@backend/src/db/schema.ts
@backend/src/db/index.ts
@backend/src/server.ts
@backend/src/middleware/auth.ts
@backend/src/config/redis.ts
@backend/src/services/sessionService.ts (for GameSession interface pattern)
@backend/src/routes/admin.ts (for route pattern reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database schema + feedback service</name>
  <files>
    backend/src/db/schema.ts
    backend/src/services/feedbackService.ts
  </files>
  <action>
**Schema changes in backend/src/db/schema.ts:**

1. Add `unique` to the import from `drizzle-orm/pg-core` (existing imports: pgSchema, serial, text, integer, boolean, timestamp, jsonb, index, primaryKey).

2. Add `flagCount` column to the existing `questions` table definition:
   - `flagCount: integer('flag_count').notNull().default(0)` — add after `violationCount` column
   - Add index: `flagCountIdx: index('idx_questions_flag_count').on(table.flagCount)` in the table's index function

3. Create new `questionFlags` table after the `collectionQuestions` table:
   ```
   questionFlags = civicTriviaSchema.table('question_flags', {
     id: serial('id').primaryKey(),
     userId: integer('user_id').notNull(),  // References users table (raw SQL table, not Drizzle-managed)
     questionId: integer('question_id').notNull().references(() => questions.id),
     sessionId: text('session_id').notNull(),  // UUID from Redis game session
     reasons: jsonb('reasons').$type<string[]>(),  // null until Phase 28
     elaborationText: text('elaboration_text'),  // null until Phase 28
     createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
   }, (table) => ({
     userQuestionUnique: unique().on(table.userId, table.questionId),
     userIdx: index('idx_question_flags_user').on(table.userId),
     questionIdx: index('idx_question_flags_question').on(table.questionId),
     createdAtIdx: index('idx_question_flags_created_at').on(table.createdAt),
   }))
   ```

   NOTE: Do NOT add `.references(() => users.id)` on userId — the `users` table is managed via raw SQL (backend/src/models/User.ts), not Drizzle schema. The foreign key will be enforced at SQL level via the migration script.

4. Export types:
   ```
   export type QuestionFlag = typeof questionFlags.$inferSelect;
   export type NewQuestionFlag = typeof questionFlags.$inferInsert;
   ```

**Feedback service in backend/src/services/feedbackService.ts:**

Create new file with two exported functions:

1. `createFlag(userId: number, questionId: number, sessionId: string): Promise<{ created: boolean; flagId: number }>`:
   - Use `db.transaction()` to atomically:
     a. INSERT into questionFlags with onConflictDoNothing on [userId, questionId]
     b. If insert returned a row (flag was created), UPDATE questions SET flag_count = flag_count + 1 WHERE id = questionId using `sql` template: `sql\`${questions.flagCount} + 1\``
   - If onConflictDoNothing returned no row (duplicate), SELECT existing flag id
   - Return `{ created: true/false, flagId }`

2. `deleteFlag(userId: number, questionId: number): Promise<boolean>`:
   - Use `db.transaction()` to atomically:
     a. DELETE from questionFlags WHERE userId = userId AND questionId = questionId, use `.returning()` to check if row existed
     b. If row was deleted, UPDATE questions SET flag_count = flag_count - 1 WHERE id = questionId (use `sql\`GREATEST(${questions.flagCount} - 1, 0)\`` to prevent going negative)
   - Return true if deleted, false if no row existed

Import `db` from `../db/index.js`, import schema tables from `../db/schema.js`, import `eq`, `and`, `sql` from `drizzle-orm`.
  </action>
  <verify>
Run `npx tsc --noEmit` from the backend directory to verify TypeScript compiles without errors. Check that schema.ts exports questionFlags and that feedbackService.ts exports createFlag and deleteFlag.
  </verify>
  <done>
schema.ts defines questionFlags table with composite unique constraint on (userId, questionId), questions table has flagCount column with index, feedbackService.ts exports createFlag (idempotent insert + flag_count increment) and deleteFlag (delete + flag_count decrement) both using transactions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rate limiter + API route + server registration</name>
  <files>
    backend/src/middleware/rateLimiter.ts
    backend/src/routes/feedback.ts
    backend/src/server.ts
  </files>
  <action>
**Rate limiter middleware in backend/src/middleware/rateLimiter.ts:**

Create new file with Redis-based rolling window rate limiter:

1. Import `redis` (the legacy Redis client) from `../config/redis.js` — this is the connected client exported at the bottom of that file, same one used by tokenUtils.

2. Constants: `RATE_LIMIT_WINDOW_SECONDS = 15 * 60` (15 minutes), `MAX_FLAGS_PER_WINDOW = 10`.

3. Export `flagRateLimiter` as Express middleware (req, res, next):
   - Get userId from `req.user?.userId` (TokenPayload uses `userId`, not `id`)
   - If no userId, return 401
   - Key: `rate_limit:flag:${userId}`
   - Use `redis.incr(key)` — atomic increment, returns current count
   - If count === 1, set expiry: `redis.expire(key, RATE_LIMIT_WINDOW_SECONDS)` (only on first increment)
   - If count > MAX_FLAGS_PER_WINDOW: get TTL with `redis.ttl(key)`, return 429 with `{ error: 'Too many flags', retryAfter: ttl }`
   - If under limit: call `next()`
   - On Redis error: fail OPEN (call `next()`) — rate limiting should not block legitimate users if Redis is down
   - Also export `getRateLimitStatus(userId: number): Promise<{ remaining: number; retryAfter: number | null }>` for frontend to optionally check status

**API route in backend/src/routes/feedback.ts:**

Create new file with Express router:

1. Import: express, body/param from express-validator, validationResult, authenticateToken from middleware/auth.js, flagRateLimiter from middleware/rateLimiter.js, createFlag/deleteFlag from services/feedbackService.js, db from db/index.js, questions from db/schema.js, eq from drizzle-orm.

2. `POST /flag` — Create flag (rate limited):
   - Middleware chain: `authenticateToken`, `flagRateLimiter`, validation for `body('questionId').isString().notEmpty()` and `body('sessionId').isString().notEmpty()`
   - Handler: validate request, get userId from `req.user!.userId`, look up question by externalId (`db.select({ id: questions.id }).from(questions).where(eq(questions.externalId, req.body.questionId)).limit(1)`), return 404 if not found
   - Call `createFlag(userId, question.id, sessionId)`
   - Return 201 if created, 200 if already existed: `{ success: true, created: result.created, flagId: result.flagId }`
   - Catch errors: return 500

3. `DELETE /flag/:questionId` — Remove flag (NOT rate limited):
   - Middleware: `authenticateToken` only (no rate limiter per research pitfall #5)
   - Handler: get questionId from params, look up question by externalId, call `deleteFlag(userId, question.id)`
   - Return 200: `{ success: true, deleted }`
   - Catch errors: return 500

Export router as default export.

**Server registration in backend/src/server.ts:**

1. Add import: `import feedbackRouter from './routes/feedback.js';`
2. Add route mount after the admin routes line: `app.use('/api/feedback', feedbackRouter);`
  </action>
  <verify>
Run `npx tsc --noEmit` from the backend directory. Verify no TypeScript errors. Check that server.ts imports and mounts the feedback router. Verify the rate limiter exports flagRateLimiter. Verify feedback.ts has POST /flag (with authenticateToken + flagRateLimiter) and DELETE /flag/:questionId (with authenticateToken only, no rate limiter).
  </verify>
  <done>
Rate limiter middleware uses Redis INCR+TTL for rolling 15-minute window (max 10 flags), fails open on Redis errors. Feedback route has POST /flag (authenticated + rate-limited) and DELETE /flag/:questionId (authenticated only, NOT rate-limited). Server.ts mounts feedback routes at /api/feedback. All TypeScript compiles.
  </done>
</task>

<task type="auto">
  <name>Task 3: Database migration script + push schema</name>
  <files>
    backend/src/scripts/migrate-question-flags.ts
  </files>
  <action>
Create a migration script at `backend/src/scripts/migrate-question-flags.ts` that applies the schema changes to the database using raw SQL via the `pool` connection (matching the pattern in backend/src/scripts/migrate-admin-role.ts):

1. Import `pool` from `../config/database.js`
2. Run in a transaction:
   a. Add `flag_count` column to `civic_trivia.questions` table:
      ```sql
      ALTER TABLE civic_trivia.questions ADD COLUMN IF NOT EXISTS flag_count INTEGER NOT NULL DEFAULT 0;
      ```
   b. Create index on flag_count:
      ```sql
      CREATE INDEX IF NOT EXISTS idx_questions_flag_count ON civic_trivia.questions(flag_count);
      ```
   c. Create `civic_trivia.question_flags` table:
      ```sql
      CREATE TABLE IF NOT EXISTS civic_trivia.question_flags (
        id SERIAL PRIMARY KEY,
        user_id INTEGER NOT NULL REFERENCES users(id),
        question_id INTEGER NOT NULL REFERENCES civic_trivia.questions(id),
        session_id TEXT NOT NULL,
        reasons JSONB,
        elaboration_text TEXT,
        created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        UNIQUE(user_id, question_id)
      );
      ```
   d. Create indexes:
      ```sql
      CREATE INDEX IF NOT EXISTS idx_question_flags_user ON civic_trivia.question_flags(user_id);
      CREATE INDEX IF NOT EXISTS idx_question_flags_question ON civic_trivia.question_flags(question_id);
      CREATE INDEX IF NOT EXISTS idx_question_flags_created_at ON civic_trivia.question_flags(created_at);
      ```
3. Log success message with counts.
4. Call `pool.end()` after completion.

After creating the script, run it against the database:
```bash
cd backend && npx tsx src/scripts/migrate-question-flags.ts
```

Then verify the table exists by running a quick check:
```bash
cd backend && npx tsx -e "
import { pool } from './src/config/database.js';
const r = await pool.query(\"SELECT column_name, data_type FROM information_schema.columns WHERE table_schema='civic_trivia' AND table_name='question_flags' ORDER BY ordinal_position\");
console.log('question_flags columns:', r.rows);
const r2 = await pool.query(\"SELECT column_name FROM information_schema.columns WHERE table_schema='civic_trivia' AND table_name='questions' AND column_name='flag_count'\");
console.log('flag_count column exists:', r2.rows.length > 0);
await pool.end();
"
```
  </action>
  <verify>
Migration script runs without errors. Database has civic_trivia.question_flags table with columns: id, user_id, question_id, session_id, reasons, elaboration_text, created_at. Database has civic_trivia.questions.flag_count column with default 0. Unique constraint exists on (user_id, question_id). TypeScript build still passes: `cd backend && npx tsc --noEmit`.
  </verify>
  <done>
Database schema applied: question_flags table created with composite unique constraint on (user_id, question_id), flag_count column added to questions table with index, all foreign keys and indexes in place. Migration script saved for reproducibility.
  </done>
</task>

</tasks>

<verification>
1. `cd backend && npx tsc --noEmit` compiles without errors
2. Migration script created and executed successfully
3. Database has question_flags table and flag_count column
4. Schema, service, middleware, route, and server files all syntactically correct
5. POST /flag uses authenticateToken + flagRateLimiter middleware chain
6. DELETE /flag/:questionId uses authenticateToken only (no rate limiter)
7. feedbackService uses transactions for atomic flag_count updates
</verification>

<success_criteria>
- question_flags table exists in database with composite unique constraint
- flag_count column exists on questions table with default 0 and index
- POST /api/feedback/flag endpoint is registered and requires authentication + rate limiting
- DELETE /api/feedback/flag/:questionId endpoint is registered and requires authentication only
- Rate limiter uses Redis INCR+TTL for rolling 15-minute window, fails open on Redis errors
- Service layer uses database transactions for atomic inserts/deletes with flag_count updates
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/27-backend-foundation-inline-flagging/27-01-SUMMARY.md`
</output>
