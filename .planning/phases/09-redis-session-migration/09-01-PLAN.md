---
phase: 09-redis-session-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/services/storage/SessionStorage.ts
  - backend/src/services/storage/MemoryStorage.ts
  - backend/src/services/storage/RedisStorage.ts
  - backend/src/config/redis.ts
  - docker-compose.yml
  - backend/.env.example
autonomous: true

must_haves:
  truths:
    - "SessionStorage interface defines async get/set/delete/count/cleanup contract"
    - "MemoryStorage implements SessionStorage with Map-based storage and manual TTL cleanup"
    - "RedisStorage implements SessionStorage with JSON serialization and SETEX atomic TTL"
    - "Redis client initializes from REDIS_URL env var with error handler and graceful fallback"
    - "Docker Compose provides local Redis for development testing"
  artifacts:
    - path: "backend/src/services/storage/SessionStorage.ts"
      provides: "Storage interface contract"
      exports: ["SessionStorage"]
    - path: "backend/src/services/storage/MemoryStorage.ts"
      provides: "In-memory storage implementation"
      exports: ["MemoryStorage"]
    - path: "backend/src/services/storage/RedisStorage.ts"
      provides: "Redis storage implementation"
      exports: ["RedisStorage"]
    - path: "backend/src/config/redis.ts"
      provides: "Redis client factory with graceful degradation"
      exports: ["storageFactory", "SessionStorageFactory"]
    - path: "docker-compose.yml"
      provides: "Local Redis service for development"
      contains: "redis:7.4-alpine"
  key_links:
    - from: "backend/src/services/storage/RedisStorage.ts"
      to: "redis client"
      via: "constructor injection of RedisClientType"
      pattern: "createClient|RedisClientType"
    - from: "backend/src/config/redis.ts"
      to: "backend/src/services/storage/RedisStorage.ts"
      via: "creates RedisStorage when REDIS_URL present, MemoryStorage otherwise"
      pattern: "new RedisStorage|new MemoryStorage"
---

<objective>
Create the storage abstraction layer for Redis session migration: interface, two implementations (Memory + Redis), Redis client configuration with graceful degradation, and Docker Compose for local development.

Purpose: This is the foundation layer that decouples SessionManager from its storage backend. Once this exists, the SessionManager can be migrated to async operations using the storage interface without changing any business logic.

Output: Four new TypeScript files (interface + 2 implementations + config), docker-compose.yml, updated .env.example
</objective>

<execution_context>
@C:\Users\Chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-redis-session-migration/09-CONTEXT.md
@.planning/phases/09-redis-session-migration/09-RESEARCH.md
@backend/src/services/sessionService.ts
@backend/package.json
@backend/src/env.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create storage interface and implementations</name>
  <files>
    backend/src/services/storage/SessionStorage.ts
    backend/src/services/storage/MemoryStorage.ts
    backend/src/services/storage/RedisStorage.ts
  </files>
  <action>
Create the `backend/src/services/storage/` directory with three files.

**SessionStorage.ts** - Define the async storage interface:
```typescript
export interface SessionStorage {
  get(sessionId: string): Promise<GameSession | null>;
  set(sessionId: string, session: GameSession, ttlSeconds: number): Promise<void>;
  delete(sessionId: string): Promise<void>;
  count(): Promise<number>;
  cleanup(): Promise<void>;
}
```
Import `GameSession` type from `../sessionService.js`.

**MemoryStorage.ts** - Extract existing Map logic from SessionManager into this class:
- Implements `SessionStorage` interface
- Uses `Map<string, GameSession>` internally
- `set()` stores session (no TTL enforcement needed — cleanup handles expiry)
- `cleanup()` removes sessions where `lastActivityTime` is older than 1 hour (same logic currently in `cleanupExpiredSessions()`)
- All methods are async (return Promises) even though Map operations are synchronous — this ensures interface compatibility

**RedisStorage.ts** - Redis-backed implementation:
- Implements `SessionStorage` interface
- Constructor takes `RedisClientType` from 'redis' package (already in package.json as ^4.6.12)
- Key format: `session:{sessionId}`
- `get()`: Calls `client.get()`, parses JSON, deserializes `createdAt` and `lastActivityTime` back to Date objects (critical — JSON.parse leaves them as strings)
- `set()`: Uses `client.setEx(key, ttlSeconds, JSON.stringify(session))` for atomic set+TTL (NOT separate set then expire — race condition pitfall)
- `delete()`: Calls `client.del()`
- `count()`: Uses `client.keys('session:*')` and returns length (acceptable for MVP — SCAN optimization deferred per RESEARCH.md)
- `cleanup()`: No-op (Redis TTL handles expiration automatically)

Important: Import `createClient` type from 'redis' for the RedisClientType. The redis package (^4.6.12) has built-in TypeScript definitions — no @types needed.
  </action>
  <verify>
Run `npx tsc --noEmit` from backend/ to confirm all three files compile without errors. Verify the interface is properly implemented by both classes (no missing methods).
  </verify>
  <done>
SessionStorage interface exists with 5 async methods. MemoryStorage implements it with Map. RedisStorage implements it with redis client, SETEX, and Date deserialization. All compile clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Redis client config, Docker Compose, and env setup</name>
  <files>
    backend/src/config/redis.ts
    docker-compose.yml
    backend/.env.example
  </files>
  <action>
**backend/src/config/redis.ts** - Create SessionStorageFactory class:
- Reads `process.env.REDIS_URL` to decide backend
- If `REDIS_URL` not set: creates MemoryStorage, logs "REDIS_URL not set, using in-memory storage", sets `isDegraded = true`
- If `REDIS_URL` set: creates Redis client with `createClient({ url: redisUrl })`, registers error handler BEFORE connecting (critical — missing error listener crashes Node.js process), connects with PING test
- On successful connection: creates RedisStorage, logs "Connected to Redis", `isDegraded = false`
- On connection failure: catches error, creates MemoryStorage fallback, logs warning, `isDegraded = true`
- Socket config: `connectTimeout: 10000` (10s), `reconnectStrategy` with exponential backoff (50ms base, max 3000ms, stop after 10 retries)
- Export `storageFactory` singleton instance
- Export `async initialize()` method that must be called during server startup
- Expose `getStorage(): SessionStorage`, `isDegradedMode(): boolean`, `isRedisHealthy(): boolean`

**docker-compose.yml** (project root):
```yaml
version: '3.8'
services:
  redis:
    image: redis:7.4-alpine
    container_name: civic-trivia-redis
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    command: redis-server --appendonly yes --maxmemory 256mb --maxmemory-policy noeviction
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 3
volumes:
  redis-data:
    driver: local
```

**backend/.env.example** - Add REDIS_URL to existing env example (create if doesn't exist, append if it does):
```
# Redis (optional - omit for in-memory storage)
REDIS_URL=redis://localhost:6379
```

Also add `redis-data` to the project root `.gitignore` if not already there.
  </action>
  <verify>
Run `npx tsc --noEmit` from backend/ to confirm redis.ts compiles. Verify docker-compose.yml is valid YAML by running `docker compose config` (if Docker available) or manual inspection. Check .env.example has REDIS_URL entry.
  </verify>
  <done>
StorageFactory initializes Redis or Memory based on REDIS_URL, with error handling and graceful fallback. Docker Compose provides local Redis with persistence (appendonly, volume mount, noeviction). .env.example documents REDIS_URL.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes in backend/
2. All 4 new TypeScript files exist in correct locations
3. SessionStorage interface has 5 methods (get, set, delete, count, cleanup)
4. RedisStorage uses setEx (not separate set + expire)
5. RedisStorage deserializes Date fields after JSON.parse
6. Redis config registers error handler before connect()
7. docker-compose.yml has redis:7.4-alpine with appendonly and noeviction
</verification>

<success_criteria>
- Storage abstraction layer compiles and follows interface contract
- Redis config provides factory pattern with graceful fallback
- Docker Compose enables local Redis testing
- No changes to existing SessionManager yet (that's Plan 02)
</success_criteria>

<output>
After completion, create `.planning/phases/09-redis-session-migration/09-01-SUMMARY.md`
</output>
