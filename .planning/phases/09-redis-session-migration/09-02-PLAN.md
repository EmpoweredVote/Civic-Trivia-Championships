---
phase: 09-redis-session-migration
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - backend/src/services/sessionService.ts
  - backend/src/routes/game.ts
  - backend/src/server.ts
  - backend/src/routes/health.ts
autonomous: true

must_haves:
  truths:
    - "SessionManager methods are all async and use storage abstraction instead of direct Map access"
    - "Game routes await all sessionManager calls without breaking existing API contracts"
    - "Health endpoint returns Redis status, storage type, uptime, and session count"
    - "Server initializes storage factory before starting HTTP listener"
    - "API responses include degraded flag when running in fallback mode"
  artifacts:
    - path: "backend/src/services/sessionService.ts"
      provides: "Async SessionManager using storage abstraction"
      exports: ["SessionManager", "sessionManager", "initializeSessionManager"]
      contains: "async createSession"
    - path: "backend/src/routes/game.ts"
      provides: "Async game routes using await for session operations"
      contains: "await sessionManager"
    - path: "backend/src/routes/health.ts"
      provides: "Health check endpoint with Redis status"
      exports: ["router"]
      contains: "/health"
    - path: "backend/src/server.ts"
      provides: "Server with async storage initialization before listen"
      contains: "storageFactory.initialize"
  key_links:
    - from: "backend/src/services/sessionService.ts"
      to: "backend/src/services/storage/SessionStorage.ts"
      via: "constructor injection of SessionStorage"
      pattern: "storage\\.(get|set|delete)"
    - from: "backend/src/server.ts"
      to: "backend/src/config/redis.ts"
      via: "calls storageFactory.initialize() at startup"
      pattern: "storageFactory\\.initialize"
    - from: "backend/src/routes/health.ts"
      to: "backend/src/config/redis.ts"
      via: "reads storageFactory.isDegradedMode and isRedisHealthy"
      pattern: "storageFactory\\.(isDegraded|isRedisHealthy)"
    - from: "backend/src/routes/game.ts"
      to: "backend/src/services/sessionService.ts"
      via: "await on all async session methods"
      pattern: "await sessionManager\\."
---

<objective>
Migrate SessionManager from synchronous Map to async storage abstraction, update all game routes to async, add health endpoint, and wire storage initialization into server startup.

Purpose: This is the core migration that makes sessions persist in Redis. The storage layer from Plan 01 provides the abstraction — this plan wires it into the existing application without breaking any API contracts.

Output: Modified sessionService.ts (async), modified game.ts (async routes), new health.ts route, modified server.ts (async init)
</objective>

<execution_context>
@C:\Users\Chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-redis-session-migration/09-CONTEXT.md
@.planning/phases/09-redis-session-migration/09-RESEARCH.md
@.planning/phases/09-redis-session-migration/09-01-SUMMARY.md
@backend/src/services/sessionService.ts
@backend/src/routes/game.ts
@backend/src/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert SessionManager to async with storage abstraction</name>
  <files>
    backend/src/services/sessionService.ts
  </files>
  <action>
Modify the existing `SessionManager` class to use the `SessionStorage` interface instead of direct `Map` operations. This is a careful refactor — all business logic (scoring, validation, wager checks, plausibility) stays EXACTLY the same. Only the storage access pattern changes.

**Changes to SessionManager:**

1. Replace `private sessions: Map<string, GameSession>` with `private storage: SessionStorage`
2. Constructor takes `SessionStorage` parameter instead of creating a Map
3. Move cleanup interval logic: only start cleanup interval if storage needs it (MemoryStorage does, RedisStorage doesn't — Redis TTL handles expiry). Check with `instanceof MemoryStorage` or add a `needsCleanup` flag.
4. Convert all methods to async:
   - `createSession()` -> `async createSession()`: calls `await this.storage.set(sessionId, session, 3600)` instead of `this.sessions.set()`
   - `getSession()` -> `async getSession()`: calls `await this.storage.get(sessionId)` instead of `this.sessions.get()`. On access, update `lastActivityTime` and re-save with `await this.storage.set()` to refresh TTL
   - `submitAnswer()` -> `async submitAnswer()`: calls `await this.getSession()` at start. After pushing answer to `session.answers`, calls `await this.storage.set(sessionId, session, 3600)` to persist the updated session
   - `getResults()` -> `async getResults()`: calls `await this.getSession()`
   - `destroy()`: also clears cleanup interval if running

5. Remove the `cleanupExpiredSessions()` private method — that logic now lives in `MemoryStorage.cleanup()`

6. Change the singleton export pattern:
   - Remove `export const sessionManager = new SessionManager()` (can't construct without storage yet)
   - Add `let sessionManager: SessionManager` variable
   - Add `export function initializeSessionManager(storage: SessionStorage): SessionManager` that creates and assigns the singleton
   - Add `export function getSessionManager(): SessionManager` that returns the singleton (throws if not initialized)
   - Keep exporting `sessionManager` but initialize it lazily

7. Keep ALL existing type exports (Question, ServerAnswer, GameSession, GameSessionResult) unchanged.

**Critical: Do NOT change any scoring logic, plausibility checks, wager validation, or API response shapes.** Only the storage access pattern changes from sync Map to async SessionStorage.
  </action>
  <verify>
Run `npx tsc --noEmit` from backend/. All methods should be async. The sessionManager should require initialization with a storage backend. Type exports remain unchanged.
  </verify>
  <done>
SessionManager uses async storage abstraction. All methods (createSession, getSession, submitAnswer, getResults) are async. Business logic unchanged. Singleton requires explicit initialization with storage backend.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update game routes to async, add health endpoint, wire server startup</name>
  <files>
    backend/src/routes/game.ts
    backend/src/routes/health.ts
    backend/src/server.ts
  </files>
  <action>
**backend/src/routes/game.ts** - Convert route handlers to async:

1. `POST /session`: Make handler `async`. Add `await` to `sessionManager.createSession()`. Import from updated sessionService.
2. `POST /answer`: Make handler `async`. Add `await` to `sessionManager.submitAnswer()` and `sessionManager.getSession()`.
3. `GET /results/:sessionId`: Already async. Add `await` to `sessionManager.getResults()` and `sessionManager.getSession()`. After getting results, include `degraded` flag in response: import `storageFactory` from config/redis.ts, add `degraded: storageFactory.isDegradedMode()` to the JSON response for `/session` and `/results/:sessionId` endpoints (per RESEARCH.md recommendation #3 — frontend checks this flag rather than polling).

All existing response shapes stay the same (new `degraded` field is additive, won't break frontend).

**backend/src/routes/health.ts** - New health check route:
```typescript
import { Router, Request, Response } from 'express';
import { storageFactory } from '../config/redis.js';

const router = Router();

router.get('/', async (_req: Request, res: Response) => {
  const storage = storageFactory.getStorage();
  const health = {
    status: 'healthy' as string,
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    storage: {
      type: storageFactory.isDegradedMode() ? 'memory' : 'redis',
      healthy: storageFactory.isRedisHealthy(),
      sessionCount: await storage.count()
    }
  };

  // Return 503 if Redis was expected (REDIS_URL set) but is down
  if (process.env.REDIS_URL && storageFactory.isDegradedMode()) {
    return res.status(503).json({
      ...health,
      status: 'degraded',
      message: 'Redis unavailable, using fallback storage'
    });
  }

  res.json(health);
});

export { router };
```

**backend/src/server.ts** - Wire async initialization:

1. Import `storageFactory` from `./config/redis.js`
2. Import `initializeSessionManager` from `./services/sessionService.js`
3. Wrap server startup in async IIFE or async function:
   ```typescript
   async function startServer() {
     // Initialize storage (Redis or Memory)
     await storageFactory.initialize();

     // Initialize session manager with storage backend
     initializeSessionManager(storageFactory.getStorage());

     // ... existing middleware and route setup ...

     // Replace existing /health route with new health router
     app.use('/health', healthRouter);

     app.listen(PORT, () => {
       console.log(`Server running on http://localhost:${PORT}`);
       console.log(`CORS enabled for: ${FRONTEND_URL}`);
       console.log(`Storage: ${storageFactory.isDegradedMode() ? 'in-memory (degraded)' : 'Redis'}`);
     });
   }

   startServer().catch(err => {
     console.error('Failed to start server:', err);
     process.exit(1);
   });
   ```

4. Remove the old inline `app.get('/health', ...)` handler — replaced by the new health router with Redis status.
  </action>
  <verify>
1. `npx tsc --noEmit` passes from backend/
2. Start server without REDIS_URL: should log "in-memory storage" and start normally
3. `curl http://localhost:3000/health` returns JSON with `storage.type: "memory"` and `status: "healthy"`
4. Start server with `REDIS_URL=redis://localhost:6379` (with Docker Redis running): should log "Connected to Redis"
5. `curl http://localhost:3000/health` returns `storage.type: "redis"`
6. Create a game session (`POST /api/game/session`), submit answers, get results — all should work as before
  </verify>
  <done>
Game routes use async/await for all session operations. Health endpoint exposes Redis status, uptime, session count. Server initializes storage before listening. API responses include degraded flag. Existing game flow works unchanged.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes in backend/
2. Server starts without Redis (in-memory mode) — no errors
3. Full game flow works: create session -> answer 10 questions -> get results
4. Health endpoint returns storage status
5. With Docker Redis: server connects, sessions persist in Redis
6. Kill Redis while server running: next requests should not crash server
7. API response shapes unchanged (additive `degraded` field only)
</verification>

<success_criteria>
- SessionManager is fully async, using storage abstraction
- Game routes await all session operations
- Health endpoint exposes Redis connection status
- Server initializes storage before accepting requests
- Existing game flow works identically in both Redis and in-memory modes
- No changes to scoring, wager, or plausibility logic
</success_criteria>

<output>
After completion, create `.planning/phases/09-redis-session-migration/09-02-SUMMARY.md`
</output>
