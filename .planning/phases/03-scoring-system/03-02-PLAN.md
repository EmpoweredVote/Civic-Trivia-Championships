---
phase: 03-scoring-system
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - frontend/src/types/game.ts
  - frontend/src/features/game/gameReducer.ts
  - frontend/src/features/game/hooks/useGameState.ts
  - frontend/src/services/gameService.ts
autonomous: true

must_haves:
  truths:
    - "Game creates a server session on start and uses sessionId for all interactions"
    - "Each answer is submitted to server and score data flows into game state"
    - "GameResult contains totalScore, totalBasePoints, totalSpeedBonus, and fastestAnswer"
    - "Client never calculates scores — all score data comes from server responses"
  artifacts:
    - path: "frontend/src/types/game.ts"
      provides: "Extended GameAnswer with basePoints, speedBonus, totalPoints, responseTime; Extended GameResult with score aggregates"
      contains: "basePoints"
    - path: "frontend/src/features/game/gameReducer.ts"
      provides: "REVEAL_ANSWER action accepts scoreData from server; GameState includes sessionId and totalScore"
      contains: "scoreData"
    - path: "frontend/src/features/game/hooks/useGameState.ts"
      provides: "startGame creates session, lockAnswer submits to server, gameResult includes score data"
      contains: "sessionId"
    - path: "frontend/src/services/gameService.ts"
      provides: "createGameSession, submitAnswer, fetchGameResults API functions"
      exports: ["createGameSession", "submitAnswer", "fetchGameResults"]
  key_links:
    - from: "frontend/src/features/game/hooks/useGameState.ts"
      to: "frontend/src/services/gameService.ts"
      via: "startGame calls createGameSession, lockAnswer calls submitAnswer"
      pattern: "createGameSession|submitAnswer"
    - from: "frontend/src/features/game/hooks/useGameState.ts"
      to: "frontend/src/features/game/gameReducer.ts"
      via: "dispatches REVEAL_ANSWER with scoreData from server"
      pattern: "scoreData"
---

<objective>
Wire the frontend to use server-side scoring. Extend types, reducer, hook, and API service so that: game start creates a server session, each answer submission goes to the server for scoring, and score data (basePoints, speedBonus, totalPoints, responseTime) flows through the state machine into GameResult.

Purpose: Client becomes a thin display layer. All scoring authority lives on the server.
Output: Updated types, reducer, hook, and gameService with full server session integration.
</objective>

<execution_context>
@C:\Users\Chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-scoring-system/03-CONTEXT.md
@.planning/phases/03-scoring-system/03-RESEARCH.md
@.planning/phases/03-scoring-system/03-01-SUMMARY.md
@frontend/src/types/game.ts
@frontend/src/features/game/gameReducer.ts
@frontend/src/features/game/hooks/useGameState.ts
@frontend/src/services/gameService.ts
@frontend/src/pages/Game.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend types and reducer for scoring</name>
  <files>
    frontend/src/types/game.ts
    frontend/src/features/game/gameReducer.ts
  </files>
  <action>
Update `frontend/src/types/game.ts`:
- Extend `GameAnswer` with: `basePoints: number`, `speedBonus: number`, `totalPoints: number`, `responseTime: number`
- Extend `GameResult` with: `totalScore: number`, `totalBasePoints: number`, `totalSpeedBonus: number`, `fastestAnswer: { questionIndex: number; responseTime: number; points: number } | null`
- Add `sessionId: string | null` to `GameState`
- Add `totalScore: number` to `GameState` (running score for display during game)

Update `frontend/src/features/game/gameReducer.ts`:
- Add `sessionId` and `totalScore` to `initialGameState` (null and 0)
- Add new action: `| { type: 'SESSION_CREATED'; sessionId: string; questions: Question[] }` — sets sessionId + questions, transitions to 'answering'
- Modify `START_GAME` action: now just transitions to a loading-like state (or keep it and have SESSION_CREATED be the real start). Recommendation: replace START_GAME with SESSION_CREATED that does the same thing but also sets sessionId.
- Update `REVEAL_ANSWER` action to accept `scoreData: { basePoints: number; speedBonus: number; totalPoints: number; correct: boolean; correctAnswer: number }` — the answer's correct/incorrect now comes from server response, not client-side comparison. Build the GameAnswer using scoreData fields. Increment `totalScore` in state.
- Update `TIMEOUT` action similarly — when timeout occurs, client still submits to server (selectedOption: null, timeRemaining: 0). The TIMEOUT action should also accept scoreData (which will be 0/0/0 since wrong).
- Keep LOCK_ANSWER as-is (just transitions to 'locked' phase, pauses timer).
- Keep NEXT_QUESTION, QUIT_GAME, SELECT_ANSWER as-is.

Important: The `correct` field on GameAnswer now comes from server scoreData, NOT from client-side `selectedOption === correctAnswer` comparison. Remove the client-side correctness check from the reducer.
  </action>
  <verify>
`cd frontend && npx tsc --noEmit` passes with updated types
  </verify>
  <done>
GameAnswer includes basePoints/speedBonus/totalPoints/responseTime. GameResult includes score aggregates and fastestAnswer. GameState tracks sessionId and running totalScore. Reducer accepts scoreData from server in REVEAL_ANSWER and TIMEOUT actions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire hook and API service to server sessions</name>
  <files>
    frontend/src/services/gameService.ts
    frontend/src/features/game/hooks/useGameState.ts
  </files>
  <action>
Update `frontend/src/services/gameService.ts`:
- Keep existing `fetchQuestions()` for backward compat (or remove — up to discretion since POST /session replaces it)
- Add `createGameSession(): Promise<{ sessionId: string; questions: Question[] }>` — POST to `/api/game/session`, returns sessionId and questions (note: questions won't have correctAnswer since server strips it)
- Add `submitAnswer(sessionId: string, questionId: string, selectedOption: number | null, timeRemaining: number): Promise<{ basePoints: number; speedBonus: number; totalPoints: number; correct: boolean; correctAnswer: number; flagged: boolean }>` — POST to `/api/game/answer`
- Add `fetchGameResults(sessionId: string): Promise<GameSessionResult>` — GET to `/api/game/results/${sessionId}` (define GameSessionResult type matching backend response)

Update `frontend/src/features/game/hooks/useGameState.ts`:
- `startGame()`: Call `createGameSession()` instead of `fetchQuestions()`. Dispatch new `SESSION_CREATED` action (or updated START_GAME) with sessionId and questions.
- `lockAnswer(timeRemaining: number)`: After dispatching LOCK_ANSWER (which starts suspense pause), during the suspense timeout, submit answer to server via `submitAnswer()`. When server responds, dispatch REVEAL_ANSWER with the scoreData from server response. This means the suspense pause doubles as the server round-trip time — if server responds before 1.5s, wait the remainder. If server takes longer, reveal as soon as response arrives.
  - Implementation: In the suspense timeout callback, call submitAnswer. The reveal happens when BOTH the suspense timer has elapsed AND the server has responded. Use a Promise + setTimeout approach:
    ```
    const [serverResponse] = await Promise.all([
      submitAnswer(sessionId, questionId, selectedOption, timeRemaining),
      new Promise(resolve => setTimeout(resolve, SUSPENSE_PAUSE_MS))
    ]);
    dispatch({ type: 'REVEAL_ANSWER', timeRemaining, scoreData: serverResponse });
    ```
  - Store sessionId in a ref so it's available in lockAnswer.
- `handleTimeout()`: Submit timeout answer to server (selectedOption: null, timeRemaining: 0), then dispatch TIMEOUT with scoreData.
- `gameResult` derivation: When phase is 'complete', build GameResult from state.answers including score aggregates (totalScore from state.totalScore, totalBasePoints/totalSpeedBonus summed from answers, fastestAnswer computed from correct answers with lowest responseTime).

Important: The Question type returned from createGameSession won't have `correctAnswer` — the server strips it. The correctAnswer comes back in the submitAnswer response. Store it on the GameAnswer so the UI can highlight correct/incorrect during reveal. This means GameAnswer or the reducer needs to also track `correctAnswer: number` so the AnswerGrid can show which option was correct. Add `correctAnswer: number` to GameAnswer type.

Update the lockAnswer flow to be async. Since useReducer dispatch is sync but we need async server call, the hook handles the async orchestration (fetch + dispatch).
  </action>
  <verify>
1. `cd frontend && npx tsc --noEmit` passes
2. Start both frontend and backend dev servers
3. Start a game — should create session (check Network tab: POST /api/game/session returns 201)
4. Answer a question — should submit to server (POST /api/game/answer) and show score data in reveal
5. Complete game — gameResult should contain score aggregates
  </verify>
  <done>
Game flow uses server sessions end-to-end: startGame creates session, lockAnswer submits to server during suspense pause and reveals with server-calculated score, timeout submits null answer, gameResult contains all score data. Client never calculates scores.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles for frontend
2. Full game flow works: start -> answer 10 questions -> results shows score data
3. Network tab confirms POST /session on start, POST /answer on each reveal
4. Score data in state matches what server returned (check React DevTools or console.log)
5. Timeout answers submit with selectedOption: null and get 0 points
</verification>

<success_criteria>
- createGameSession replaces fetchQuestions as the game start mechanism
- Every answer goes through POST /answer before reveal shows
- GameResult contains totalScore, totalBasePoints, totalSpeedBonus, fastestAnswer
- Running totalScore in state increments after each answered question
- No client-side score calculation exists
</success_criteria>

<output>
After completion, create `.planning/phases/03-scoring-system/03-02-SUMMARY.md`
</output>
