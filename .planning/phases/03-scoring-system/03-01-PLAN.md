---
phase: 03-scoring-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/services/sessionService.ts
  - backend/src/services/scoreService.ts
  - backend/src/routes/game.ts
  - backend/src/server.ts
autonomous: true

must_haves:
  truths:
    - "Server creates a game session when game starts and returns sessionId"
    - "Server validates and scores each answer submission with base points and speed bonus"
    - "Server rejects answers for invalid/expired sessions"
    - "Abandoned sessions are cleaned up automatically"
  artifacts:
    - path: "backend/src/services/sessionService.ts"
      provides: "SessionManager class with create, get, submitAnswer, getResults, cleanup"
      exports: ["sessionManager"]
    - path: "backend/src/services/scoreService.ts"
      provides: "Score calculation with 3-tier speed bonus"
      exports: ["calculateScore", "calculateSpeedBonus"]
    - path: "backend/src/routes/game.ts"
      provides: "POST /session, POST /answer, GET /results endpoints"
  key_links:
    - from: "backend/src/routes/game.ts"
      to: "backend/src/services/sessionService.ts"
      via: "route handlers call sessionManager methods"
      pattern: "sessionManager\\."
    - from: "backend/src/services/sessionService.ts"
      to: "backend/src/services/scoreService.ts"
      via: "submitAnswer calls calculateScore"
      pattern: "calculateScore"
---

<objective>
Build server-side game session tracking and score calculation. The server becomes the authority for all scoring — creating sessions when games start, validating each answer submission, calculating base points (+100) and speed bonuses (3 tiers: +50/+25/+0), and running plausibility checks.

Purpose: Prevents client-side score manipulation. Server owns all scoring logic.
Output: Session service, score service, and 3 new API endpoints (create session, submit answer, get results).
</objective>

<execution_context>
@C:\Users\Chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-scoring-system/03-CONTEXT.md
@.planning/phases/03-scoring-system/03-RESEARCH.md
@backend/src/routes/game.ts
@backend/src/server.ts
@frontend/src/types/game.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create score service and session service</name>
  <files>
    backend/src/services/scoreService.ts
    backend/src/services/sessionService.ts
  </files>
  <action>
Create `backend/src/services/scoreService.ts`:
- Export `calculateSpeedBonus(timeRemaining: number): number` — 3 tiers per CONTEXT.md:
  - Fast: timeRemaining >= 15 (out of 25s) -> +50
  - Medium: timeRemaining >= 5 -> +25
  - Slow: timeRemaining < 5 -> +0
- Export `calculateScore(isCorrect: boolean, timeRemaining: number): { basePoints: number; speedBonus: number; totalPoints: number }` — basePoints is 100 if correct else 0, speedBonus only if correct
- Export `calculateResponseTime(questionDuration: number, timeRemaining: number): number` — returns seconds taken to answer (for "fastest answer" stat)

Create `backend/src/services/sessionService.ts`:
- Define `GameSession` interface: sessionId, userId, questions (Question[]), answers (ServerAnswer[]), createdAt, lastActivityTime
- Define `ServerAnswer` interface: questionId, selectedOption (number | null), timeRemaining, basePoints, speedBonus, totalPoints, responseTime, flagged (boolean for plausibility)
- Define `GameSessionResult` interface: answers (ServerAnswer[]), totalScore, totalBasePoints, totalSpeedBonus, totalCorrect, totalQuestions, fastestAnswer ({ questionIndex, responseTime, points } | null)
- Create `SessionManager` class with Map-based storage:
  - `createSession(userId: string, questions: Question[]): string` — generates crypto.randomUUID sessionId, stores session, returns sessionId
  - `getSession(sessionId: string): GameSession | null` — returns session, updates lastActivityTime
  - `submitAnswer(sessionId: string, questionId: string, selectedOption: number | null, timeRemaining: number): ServerAnswer` — validates session exists, validates questionId is in session's questions, checks question hasn't already been answered (idempotent by questionId), runs plausibility checks (flag if responseTime < 0.5s or timeRemaining > 25), calculates score via scoreService, appends answer, returns ServerAnswer
  - `getResults(sessionId: string): GameSessionResult` — aggregates all answers into result with totals and fastestAnswer calculation
  - Private `cleanupExpiredSessions()` — removes sessions older than 1 hour (based on lastActivityTime)
  - Constructor starts cleanup interval every 5 minutes
- Export singleton: `export const sessionManager = new SessionManager();`
- Import Question type — define it locally in this file (don't import from frontend). Use same shape: { id, text, options, correctAnswer, explanation, difficulty, topic }
- Plausibility handling: set `flagged: true` on suspicious answers but still calculate normal score (log warning, don't penalize for MVP per CONTEXT.md)
  </action>
  <verify>
TypeScript compiles without errors: `cd backend && npx tsc --noEmit`
  </verify>
  <done>
scoreService exports calculateScore and calculateSpeedBonus with correct 3-tier logic. sessionManager creates sessions, validates/scores answers with plausibility checks, aggregates results, and auto-cleans expired sessions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add session and answer API endpoints</name>
  <files>
    backend/src/routes/game.ts
    backend/src/server.ts
  </files>
  <action>
Modify `backend/src/routes/game.ts` to add 3 new endpoints alongside existing GET /questions:

1. `POST /session` — Creates a game session
   - Accepts: `{ questionIds?: string[] }` (optional — if not provided, server picks 10 random questions like GET /questions does)
   - If questionIds provided, validate they exist in the question bank
   - Calls sessionManager.createSession() with userId from auth middleware (or "anonymous" if no auth — for now, don't require auth since Phase 1 auth is optional for game play)
   - Returns: `{ sessionId: string, questions: Question[] }` (questions WITHOUT correctAnswer field — strip it before sending to prevent client cheating)
   - Status 201

2. `POST /answer` — Submits an answer for scoring
   - Accepts: `{ sessionId: string, questionId: string, selectedOption: number | null, timeRemaining: number }`
   - Validates all fields present
   - Calls sessionManager.submitAnswer()
   - Returns: `{ basePoints: number, speedBonus: number, totalPoints: number, correct: boolean, correctAnswer: number, flagged: boolean }`
   - Include `correctAnswer` in response so client can show reveal (server already has the truth)
   - Status 200 on success, 400 on validation error, 404 on invalid session

3. `GET /results/:sessionId` — Gets final game results
   - Calls sessionManager.getResults()
   - Returns: full GameSessionResult object
   - Status 200 on success, 404 on invalid session

Keep existing `GET /questions` endpoint unchanged (backward compatible).

For the Question type used in backend, import from sessionService or define a shared backend type. The key thing: when returning questions from POST /session, strip the `correctAnswer` field. Create a helper function `stripAnswers(questions: Question[]): Omit<Question, 'correctAnswer'>[]`.

Do NOT modify server.ts — the game router is already mounted at `/api/game`. The new endpoints will be at `/api/game/session`, `/api/game/answer`, `/api/game/results/:sessionId`.
  </action>
  <verify>
1. TypeScript compiles: `cd backend && npx tsc --noEmit`
2. Start backend and test manually with curl or via dev server:
   - `POST /api/game/session` returns 201 with sessionId and questions (no correctAnswer in questions)
   - `POST /api/game/answer` with valid sessionId returns score data
   - `GET /api/game/results/:sessionId` returns aggregated results
  </verify>
  <done>
Three new endpoints operational: POST /session creates game with stripped questions, POST /answer validates and scores with server authority, GET /results returns aggregated breakdown. Existing GET /questions still works.
  </done>
</task>

</tasks>

<verification>
1. `cd backend && npx tsc --noEmit` passes
2. Start dev server, create session via POST, submit 2-3 answers, verify score calculation matches 3-tier bonus rules
3. Verify questions returned from POST /session do NOT contain correctAnswer
4. Verify answer response includes correctAnswer for client reveal
5. Verify plausibility flagging logs warning for timeRemaining > 25 or responseTime < 0.5s
</verification>

<success_criteria>
- POST /api/game/session returns sessionId + questions without answers
- POST /api/game/answer returns server-calculated score with base + speed bonus
- Speed bonus tiers: >= 15s remaining = +50, >= 5s = +25, < 5s = +0
- Suspicious answers flagged but not penalized
- Sessions auto-expire after 1 hour of inactivity
</success_criteria>

<output>
After completion, create `.planning/phases/03-scoring-system/03-01-SUMMARY.md`
</output>
