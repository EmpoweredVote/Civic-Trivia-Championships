---
phase: 18-foundation-admin-auth-telemetry
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/db/schema.ts
  - backend/src/services/telemetryService.ts
  - backend/src/routes/game.ts
autonomous: true

must_haves:
  truths:
    - "After a player answers a question, encounter_count increments by 1 for that question"
    - "After a player answers correctly, both encounter_count and correct_count increment by 1"
    - "After a player answers incorrectly, encounter_count increments but correct_count does not"
    - "Telemetry recording does not block or slow down the answer submission response"
    - "All users count (authenticated and anonymous)"
  artifacts:
    - path: "backend/src/db/schema.ts"
      provides: "encounter_count and correct_count columns on questions table"
      contains: "encounterCount"
    - path: "backend/src/services/telemetryService.ts"
      provides: "Fire-and-forget telemetry recording function"
      exports: ["recordQuestionTelemetry"]
    - path: "backend/src/routes/game.ts"
      provides: "Telemetry call wired into answer submission"
      contains: "recordQuestionTelemetry"
  key_links:
    - from: "backend/src/routes/game.ts"
      to: "backend/src/services/telemetryService.ts"
      via: "Fire-and-forget call after computing answer result"
      pattern: "recordQuestionTelemetry.*\\.catch"
    - from: "backend/src/services/telemetryService.ts"
      to: "backend/src/db/schema.ts"
      via: "Atomic SQL increment on questions table"
      pattern: "encounter_count.*\\+.*1|encounterCount.*sql"
---

<objective>
Add encounter_count and correct_count telemetry columns to the questions table and wire fire-and-forget recording into the answer submission flow.

Purpose: Start accumulating gameplay data immediately so later phases (quality scoring, admin UI) have real telemetry. Every question answer records whether it was encountered and whether it was answered correctly.
Output: Two new columns on questions table, telemetry service, and wiring into POST /api/game/answer.
</objective>

<execution_context>
@C:\Users\Chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-foundation-admin-auth-telemetry/18-CONTEXT.md
@.planning/phases/18-foundation-admin-auth-telemetry/18-RESEARCH.md

@backend/src/db/schema.ts
@backend/src/routes/game.ts
@backend/src/services/questionService.ts
@backend/src/db/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add telemetry columns to questions schema and run migration</name>
  <files>
    backend/src/db/schema.ts
    backend/src/scripts/migrate-telemetry.ts
  </files>
  <action>
  1. **Update Drizzle schema (`backend/src/db/schema.ts`):**
     Add two new columns to the `questions` table definition, after the `updatedAt` column:
     ```typescript
     encounterCount: integer('encounter_count').notNull().default(0),
     correctCount: integer('correct_count').notNull().default(0),
     ```
     These are integer columns with NOT NULL DEFAULT 0. PostgreSQL 11+ applies the default instantly without table rewrite.

  2. **Create migration script (`backend/src/scripts/migrate-telemetry.ts`):**
     A script that uses the Drizzle `db` connection to run raw SQL:
     ```typescript
     import { sql } from 'drizzle-orm';
     import { db } from '../db/index.js';

     async function migrateTelemetry() {
       console.log('Adding telemetry columns to questions table...');
       await db.execute(sql`
         ALTER TABLE civic_trivia.questions
         ADD COLUMN IF NOT EXISTS encounter_count INTEGER NOT NULL DEFAULT 0,
         ADD COLUMN IF NOT EXISTS correct_count INTEGER NOT NULL DEFAULT 0
       `);
       console.log('Telemetry columns added successfully.');
       process.exit(0);
     }

     migrateTelemetry().catch(err => {
       console.error('Migration failed:', err);
       process.exit(1);
     });
     ```
     Run this script to apply the migration to the database.

  3. **Run the migration:**
     Execute `npx tsx backend/src/scripts/migrate-telemetry.ts` to add the columns.

  IMPORTANT: The questions table IS in the Drizzle schema (`backend/src/db/schema.ts`), unlike users. So updating the schema definition keeps Drizzle in sync with the database. The script applies the actual ALTER TABLE.
  </action>
  <verify>
    - `npx tsx backend/src/scripts/migrate-telemetry.ts` runs without error
    - TypeScript compiles: `cd backend && npx tsc --noEmit`
    - Schema file has encounterCount and correctCount on questions table
  </verify>
  <done>
    - encounter_count and correct_count columns exist on civic_trivia.questions table
    - Both columns are INTEGER NOT NULL DEFAULT 0
    - Drizzle schema definition matches database state
    - Existing questions all have 0 for both counters
  </done>
</task>

<task type="auto">
  <name>Task 2: Create telemetry service and wire into answer submission</name>
  <files>
    backend/src/services/telemetryService.ts
    backend/src/routes/game.ts
  </files>
  <action>
  1. **Create telemetry service (`backend/src/services/telemetryService.ts`):**
     ```typescript
     import { db } from '../db/index.js';
     import { questions } from '../db/schema.js';
     import { eq, sql } from 'drizzle-orm';

     /**
      * Record a question encounter and optionally a correct answer.
      * Uses atomic SQL increment to avoid race conditions.
      * Designed to be called fire-and-forget -- errors are logged, never thrown to caller.
      */
     export async function recordQuestionTelemetry(
       questionId: number,
       wasCorrect: boolean
     ): Promise<void> {
       try {
         if (wasCorrect) {
           await db.update(questions).set({
             encounterCount: sql`${questions.encounterCount} + 1`,
             correctCount: sql`${questions.correctCount} + 1`,
           }).where(eq(questions.id, questionId));
         } else {
           await db.update(questions).set({
             encounterCount: sql`${questions.encounterCount} + 1`,
           }).where(eq(questions.id, questionId));
         }
       } catch (error) {
         console.error('Telemetry recording failed for question', questionId, error);
       }
     }
     ```

     Key design decisions:
     - Takes the **database integer ID** (not externalId) because that's what Drizzle queries use
     - Atomic `encounter_count + 1` avoids race conditions from concurrent gameplay
     - try/catch with console.error -- errors are logged but never propagated
     - Single function handles both correct and incorrect (conditional SQL)

  2. **Wire into answer submission (`backend/src/routes/game.ts`):**
     In the `POST /answer` route handler, after computing the answer result but BEFORE sending the response:

     - Import `recordQuestionTelemetry` from telemetryService
     - Need the database integer ID, not the external string ID. The `questionId` in the request body is the external string ID (e.g., "q001"). Look up the database question from the session:
       ```typescript
       // The session question has externalId as `id` field (from questionService transform)
       // We need the DB integer id. Query it from the questions table.
       ```
     - However, examining the code more carefully: the session stores questions with `id` as the externalId string. We need the DB integer id for the telemetry update. Two approaches:
       a. Query the DB to resolve externalId -> id (adds a query per answer)
       b. Use externalId in the telemetry function (change WHERE clause to use externalId)

     **Use approach (b)** -- modify telemetryService to accept externalId string:
     ```typescript
     export async function recordQuestionTelemetry(
       externalId: string,
       wasCorrect: boolean
     ): Promise<void> {
       // ... use eq(questions.externalId, externalId) instead of eq(questions.id, questionId)
     }
     ```
     This avoids an extra DB query per answer submission.

     - Determine correctness: `const wasCorrect = answer.basePoints > 0 || (answer.wager !== undefined && answer.totalPoints > 0)` (same logic already used for the `correct` field in the response).

     - Call fire-and-forget BEFORE `res.status(200).json(...)`:
       ```typescript
       // Fire-and-forget telemetry -- do not await, do not block response
       recordQuestionTelemetry(questionId, wasCorrect).catch(() => {});
       ```
       The `.catch(() => {})` is a safety net on top of the internal try/catch. The response is sent immediately without waiting for telemetry.

     - This records telemetry for ALL users (authenticated and anonymous) since the answer route does not require authentication.
  </action>
  <verify>
    - TypeScript compiles: `cd backend && npx tsc --noEmit`
    - telemetryService.ts exists and exports recordQuestionTelemetry
    - game.ts POST /answer route calls recordQuestionTelemetry with .catch(() => {})
    - The telemetry call is NOT awaited (fire-and-forget pattern)
    - `cd backend && npm run build` succeeds (if build script exists)
  </verify>
  <done>
    - recordQuestionTelemetry function exists in telemetryService.ts
    - Uses atomic SQL increment (encounter_count = encounter_count + 1)
    - Errors are caught and logged, never propagated
    - POST /api/game/answer calls telemetry fire-and-forget on every answer
    - Telemetry does not block the answer response
    - Both correct and incorrect answers increment encounter_count
    - Only correct answers increment correct_count
    - Works for both authenticated and anonymous users
  </done>
</task>

</tasks>

<verification>
1. Migration adds encounter_count and correct_count to questions table
2. TypeScript compiles: `cd backend && npx tsc --noEmit`
3. Answering a question increments encounter_count in database
4. Answering correctly increments both encounter_count and correct_count
5. Answering incorrectly increments only encounter_count
6. Answer submission response time is not affected by telemetry
7. Telemetry failure does not crash the answer endpoint
</verification>

<success_criteria>
- encounter_count and correct_count columns exist on questions table (DEFAULT 0)
- Every answer submission triggers telemetry recording
- Telemetry is fire-and-forget (does not block response)
- Atomic SQL increments prevent race conditions
- Telemetry errors are logged, never propagated to player
- Both authenticated and anonymous gameplay is tracked
</success_criteria>

<output>
After completion, create `.planning/phases/18-foundation-admin-auth-telemetry/18-03-SUMMARY.md`
</output>
