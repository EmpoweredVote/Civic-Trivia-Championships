---
phase: 14-question-service-route-integration
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - backend/src/routes/game.ts
  - backend/src/services/sessionService.ts
  - frontend/src/services/gameService.ts
  - frontend/src/types/game.ts
autonomous: true

must_haves:
  truths:
    - "POST /session accepts optional collectionId in request body and returns questions from that collection"
    - "Omitting collectionId defaults to Federal Civics collection (backward compatible)"
    - "Session response includes collectionName and collectionSlug metadata"
    - "Results response includes collectionName and collectionSlug metadata"
    - "readFileSync JSON loading at module top-level in game.ts is removed"
    - "GET /questions endpoint still works (legacy, uses QuestionService with Federal default)"
    - "Frontend createGameSession can optionally pass collectionId"
    - "Recently played questions are tracked per user and excluded from selection"
  artifacts:
    - path: "backend/src/routes/game.ts"
      provides: "Updated game routes using QuestionService instead of JSON"
      contains: "selectQuestionsForGame"
    - path: "backend/src/services/sessionService.ts"
      provides: "GameSession with collection metadata fields"
      contains: "collectionName"
    - path: "frontend/src/services/gameService.ts"
      provides: "Updated createGameSession accepting optional collectionId"
      contains: "collectionId"
    - path: "frontend/src/types/game.ts"
      provides: "GameState with collection metadata"
      contains: "collectionName"
  key_links:
    - from: "backend/src/routes/game.ts"
      to: "backend/src/services/questionService.ts"
      via: "import { selectQuestionsForGame, getCollectionMetadata, getFederalCollectionId }"
      pattern: "selectQuestionsForGame"
    - from: "backend/src/routes/game.ts"
      to: "backend/src/services/sessionService.ts"
      via: "sessionManager.createSession with collection metadata"
      pattern: "createSession"
    - from: "frontend/src/services/gameService.ts"
      to: "/api/game/session"
      via: "POST with optional collectionId body field"
      pattern: "collectionId"
---

<objective>
Wire QuestionService into game routes, replacing the static JSON loading with database queries. Update session creation to accept optional collectionId, include collection metadata in responses, and track recently-played questions per user.

Purpose: This plan completes the data layer swap. After this, the game is running on PostgreSQL-sourced questions with collection scoping, while maintaining 100% backward compatibility for existing clients that don't send collectionId.

Output: Updated `game.ts` routes, `sessionService.ts` with collection metadata, and frontend types/service to support collection-scoped games.
</objective>

<execution_context>
@C:\Users\Chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-question-service-route-integration/14-CONTEXT.md
@.planning/phases/14-question-service-route-integration/14-RESEARCH.md
@.planning/phases/14-question-service-route-integration/14-01-SUMMARY.md
@backend/src/routes/game.ts
@backend/src/services/sessionService.ts
@backend/src/services/questionService.ts
@frontend/src/services/gameService.ts
@frontend/src/types/game.ts
@frontend/src/features/game/hooks/useGameState.ts
@frontend/src/features/game/gameReducer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update backend routes and session to use QuestionService</name>
  <files>backend/src/routes/game.ts, backend/src/services/sessionService.ts</files>
  <action>
**Update `backend/src/services/sessionService.ts`:**

Add collection metadata fields to the `GameSession` interface:
```typescript
export interface GameSession {
  // ... existing fields unchanged ...
  collectionId: number | null;    // null = Federal default (backward compat)
  collectionName: string | null;  // e.g. "Federal Civics"
  collectionSlug: string | null;  // e.g. "federal-civics"
}
```

Update `createSession` method signature to accept collection metadata:
```typescript
async createSession(
  userId: string | number,
  questions: Question[],
  collectionMeta?: { id: number; name: string; slug: string }
): Promise<string>
```

In the createSession body, set the new fields:
```typescript
collectionId: collectionMeta?.id ?? null,
collectionName: collectionMeta?.name ?? null,
collectionSlug: collectionMeta?.slug ?? null,
```

This is backward compatible — existing callers that don't pass collectionMeta get nulls.

**Update `backend/src/routes/game.ts`:**

1. **Remove top-level JSON loading.** Delete these lines:
   ```
   const questionsPath = join(__dirname, '../data/questions.json');
   const questionsData = readFileSync(questionsPath, 'utf-8');
   const allQuestions: Question[] = JSON.parse(questionsData);
   ```
   Also remove the `readFileSync` and related imports (`fileURLToPath`, `dirname`, `join`) ONLY IF they are no longer used elsewhere in the file. The `shuffle` function can stay (may still be useful), but the JSON loading must go — QuestionService handles all fallback internally.

2. **Add imports from QuestionService:**
   ```typescript
   import { selectQuestionsForGame, getCollectionMetadata, getFederalCollectionId } from '../services/questionService.js';
   ```

3. **Add in-memory recent question tracking:**
   Create a module-level Map to track recently-played questions per user:
   ```typescript
   // Track recent questions per user (last 30 question IDs)
   const recentQuestions = new Map<string | number, string[]>();
   const MAX_RECENT = 30;

   function getRecentQuestionIds(userId: string | number): string[] {
     return recentQuestions.get(userId) || [];
   }

   function recordPlayedQuestions(userId: string | number, questionIds: string[]): void {
     const existing = recentQuestions.get(userId) || [];
     const updated = [...questionIds, ...existing].slice(0, MAX_RECENT);
     recentQuestions.set(userId, updated);
   }
   ```

4. **Update GET /questions endpoint** to use QuestionService:
   ```typescript
   router.get('/questions', async (_req: Request, res: Response) => {
     try {
       const questions = await selectQuestionsForGame(null, []);
       res.status(200).json({ questions });
     } catch (error) {
       console.error('Error fetching questions:', error);
       res.status(500).json({ error: 'Failed to fetch questions' });
     }
   });
   ```
   Note: This becomes async now. The `null` collectionId defaults to Federal.

5. **Update POST /session endpoint:**
   - Accept optional `collectionId` from request body (alongside existing `questionIds`):
     ```typescript
     const { questionIds, collectionId } = req.body;
     ```
   - If `questionIds` is provided, keep existing behavior (look up questions by ID) BUT use QuestionService's fallback JSON loader instead of the removed `allQuestions` variable. Actually — since we removed allQuestions, we need to handle this differently. The `questionIds` path was a legacy pattern; now that questions come from the database, we can simplify:
     - If `questionIds` is provided: This is a legacy path. For backward compatibility, call `selectQuestionsForGame(null, [])` and filter to matching IDs. If any ID doesn't match, fall through to normal selection.
     - If `questionIds` is NOT provided (normal path): Call `selectQuestionsForGame(collectionId ?? null, getRecentQuestionIds(userId))`.
   - Look up collection metadata:
     ```typescript
     const resolvedCollectionId = collectionId ?? await getFederalCollectionId();
     const collectionMeta = await getCollectionMetadata(resolvedCollectionId);
     ```
   - Pass collection metadata to createSession:
     ```typescript
     const sessionId = await sessionManager.createSession(
       userId,
       selectedQuestions,
       collectionMeta ? { id: collectionMeta.id, name: collectionMeta.name, slug: collectionMeta.slug } : undefined
     );
     ```
   - After creating session, record played questions:
     ```typescript
     recordPlayedQuestions(userId, selectedQuestions.map(q => q.id));
     ```
   - Add collection metadata to response:
     ```typescript
     res.status(201).json({
       sessionId,
       questions: stripAnswers(selectedQuestions),
       degraded: storageFactory.isDegradedMode(),
       collectionName: collectionMeta?.name ?? 'Federal Civics',
       collectionSlug: collectionMeta?.slug ?? 'federal-civics',
     });
     ```

6. **Update GET /results/:sessionId endpoint:**
   - After getting the session, include collection metadata in response:
     ```typescript
     res.status(200).json({
       ...results,
       answers: cleanedAnswers,
       progression,
       degraded: storageFactory.isDegradedMode(),
       collectionName: session.collectionName ?? 'Federal Civics',
       collectionSlug: session.collectionSlug ?? 'federal-civics',
     });
     ```

**Important:** Keep the `shuffle` function and `stripAnswers` function — they are still used. Remove ONLY the JSON file loading lines and unused imports.
  </action>
  <verify>
Run `npx tsc --noEmit` from `backend/` directory to verify compilation. Check that `game.ts` no longer contains `readFileSync` for questions.json loading at module scope. Check that `game.ts` imports from `questionService.js`. Check that `sessionService.ts` GameSession interface includes `collectionName`, `collectionSlug`, `collectionId`.
  </verify>
  <done>
Backend routes use QuestionService for all question selection. POST /session accepts optional collectionId, defaults to Federal. Session and results responses include collection metadata. Recent question tracking is in place. readFileSync top-level loading is removed from game.ts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update frontend types and gameService for collection support</name>
  <files>frontend/src/services/gameService.ts, frontend/src/types/game.ts</files>
  <action>
**Update `frontend/src/types/game.ts`:**

Add collection metadata to GameState:
```typescript
export type GameState = {
  // ... all existing fields unchanged ...
  collectionName: string | null;  // Name of collection being played
  collectionSlug: string | null;  // Slug of collection being played
};
```

**Update `frontend/src/services/gameService.ts`:**

1. Update `createGameSession` to accept optional `collectionId` parameter:
   ```typescript
   export async function createGameSession(collectionId?: number): Promise<{
     sessionId: string;
     questions: Question[];
     degraded: boolean;
     collectionName: string;
     collectionSlug: string;
   }> {
     const body = collectionId ? JSON.stringify({ collectionId }) : undefined;
     const response = await apiRequest<{
       sessionId: string;
       questions: Question[];
       degraded?: boolean;
       collectionName?: string;
       collectionSlug?: string;
     }>(
       '/api/game/session',
       {
         method: 'POST',
         ...(body ? { body } : {}),
       }
     );

     return {
       sessionId: response.sessionId,
       questions: response.questions,
       degraded: response.degraded ?? false,
       collectionName: response.collectionName ?? 'Federal Civics',
       collectionSlug: response.collectionSlug ?? 'federal-civics',
     };
   }
   ```

2. Update `GameSessionResult` interface to include collection metadata:
   ```typescript
   export interface GameSessionResult {
     // ... existing fields unchanged ...
     collectionName?: string;
     collectionSlug?: string;
   }
   ```

**Update `frontend/src/features/game/gameReducer.ts`:**

1. Add `collectionName: null` and `collectionSlug: null` to `initialGameState`.

2. In the `SESSION_CREATED` action handler, set the collection fields:
   ```typescript
   case 'SESSION_CREATED':
     return {
       ...state,
       // ... existing fields ...
       collectionName: action.collectionName ?? null,
       collectionSlug: action.collectionSlug ?? null,
     };
   ```

3. Add `collectionName` and `collectionSlug` to the action type for SESSION_CREATED.

4. In `QUIT_GAME` and any reset actions, reset collection fields to null.

**Update `frontend/src/features/game/hooks/useGameState.ts`:**

1. Update the `startGame` function to pass collection metadata through to dispatch:
   ```typescript
   const startGame = async () => {
     try {
       const { sessionId, questions, degraded, collectionName, collectionSlug } = await createGameSession();
       sessionIdRef.current = sessionId;
       setHasShownTooltip(false);
       dispatch({ type: 'SESSION_CREATED', sessionId, questions, degraded, collectionName, collectionSlug });
     } catch (error) {
       console.error('Failed to create game session:', error);
     }
   };
   ```

**Important considerations:**
- ALL changes are additive — existing fields and behavior are unchanged.
- The `collectionId` parameter to `createGameSession` is optional. Phase 15 (Collection Picker UI) will use it. For now, no caller passes it, so Federal is always used.
- Do NOT change the Question type — it stays exactly as-is. The backend transformation handles mapping DB rows to this shape.
- The gameReducer action type union will need the new fields added to the SESSION_CREATED action type.
  </action>
  <verify>
Run `npx tsc --noEmit` from `frontend/` directory to verify compilation. Check that `gameService.ts` exports `createGameSession` with optional `collectionId` parameter. Check that `GameState` type includes `collectionName` and `collectionSlug`. Run `npm run build` from frontend/ to verify production build succeeds.
  </verify>
  <done>
Frontend supports collection metadata throughout the game flow. `createGameSession` accepts optional `collectionId` (unused until Phase 15). GameState carries collection context. All types compile cleanly. Zero regression for current game flow since collectionId defaults to Federal.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes in both backend/ and frontend/ directories
- `npm run build` succeeds in frontend/ (production build)
- `game.ts` no longer has `readFileSync` loading `questions.json` at module scope
- `game.ts` imports and calls `selectQuestionsForGame` from questionService
- POST /session route accepts `collectionId` body parameter
- POST /session response includes `collectionName` and `collectionSlug`
- GET /results response includes `collectionName` and `collectionSlug`
- `GameSession` interface includes `collectionId`, `collectionName`, `collectionSlug`
- Frontend `createGameSession` accepts optional `collectionId` parameter
- Frontend `GameState` includes `collectionName` and `collectionSlug`
- Recent question tracking map exists in game.ts with MAX_RECENT=30
</verification>

<success_criteria>
The game route uses QuestionService for all question selection. POST /session accepts optional collectionId (defaults to Federal). Session responses include collection metadata. Frontend types and services support collection context. The readFileSync JSON loading pattern is fully replaced. All TypeScript compiles cleanly in both backend and frontend.
</success_criteria>

<output>
After completion, create `.planning/phases/14-question-service-route-integration/14-02-SUMMARY.md`
</output>
