---
phase: 14-question-service-route-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/services/questionService.ts
autonomous: true

must_haves:
  truths:
    - "QuestionService returns 10 questions with difficulty ordering: Q1=easy, Q10=hard, Q2-Q9=balanced mix"
    - "QuestionService excludes recently-seen question IDs from selection"
    - "QuestionService falls back silently to JSON when database query fails"
    - "Database rows are transformed to match existing Question interface exactly (externalId->id, topicId->topic string)"
    - "Constraints relax gracefully when collection is too small to satisfy difficulty rules"
  artifacts:
    - path: "backend/src/services/questionService.ts"
      provides: "Collection-scoped question selection with difficulty ordering, recent exclusion, and JSON fallback"
      exports: ["selectQuestionsForGame", "getCollectionMetadata", "getFederalCollectionId"]
  key_links:
    - from: "backend/src/services/questionService.ts"
      to: "backend/src/db/index.ts"
      via: "import { db } from '../db/index.js'"
      pattern: "db\\.select"
    - from: "backend/src/services/questionService.ts"
      to: "backend/src/db/schema.ts"
      via: "import { questions, collections, collectionQuestions, topics } from '../db/schema.js'"
      pattern: "from.*schema"
    - from: "backend/src/services/questionService.ts"
      to: "backend/src/data/questions.json"
      via: "readFileSync fallback when DB fails"
      pattern: "readFileSync|questions\\.json"
---

<objective>
Create the QuestionService module that handles collection-scoped question selection from PostgreSQL with difficulty-balanced ordering, recent-question exclusion, and silent JSON fallback.

Purpose: This is the core data layer replacement — moving from a static JSON file read to intelligent database queries. All downstream game behavior depends on this service returning correctly shaped Question[] arrays.

Output: `backend/src/services/questionService.ts` — a stateless module exporting functions for question selection, collection lookup, and federal collection ID resolution.
</objective>

<execution_context>
@C:\Users\Chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-question-service-route-integration/14-CONTEXT.md
@.planning/phases/14-question-service-route-integration/14-RESEARCH.md
@backend/src/db/schema.ts
@backend/src/db/index.ts
@backend/src/services/sessionService.ts
@backend/src/routes/game.ts
@backend/src/config/database.ts
@backend/src/data/questions.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create QuestionService module with selection algorithm and fallback</name>
  <files>backend/src/services/questionService.ts</files>
  <action>
Create `backend/src/services/questionService.ts` as a stateless module (NOT a class) following the existing service pattern (progressionService, scoreService).

**Exports to create:**

1. `selectQuestionsForGame(collectionId: number | null, recentQuestionIds: string[]): Promise<Question[]>`
   - The main entry point. Returns exactly 10 questions shaped as the existing `Question` interface from sessionService.ts.
   - If `collectionId` is null, resolve the Federal Civics collection ID first (query collections table for slug='federal-civics').
   - Query questions from the database via Drizzle ORM:
     - INNER JOIN `collectionQuestions` on `questions.id = collectionQuestions.questionId`
     - WHERE `collectionQuestions.collectionId = targetCollectionId`
     - AND `questions.externalId NOT IN (recentQuestionIds)` (skip if array is empty)
     - AND `questions.expiresAt IS NULL OR questions.expiresAt > NOW()` (exclude expired)
   - Apply difficulty selection algorithm (see below).
   - Transform DB rows to match the existing `Question` interface using a topic name lookup map.
   - Wrap entire function in try-catch: on ANY error, log with `console.warn('Database question query failed, falling back to JSON:', error)` and return `loadQuestionsFromJSON()`.

2. `getCollectionMetadata(collectionId: number): Promise<{ id: number; name: string; slug: string } | null>`
   - Query the `collections` table by ID, return `{ id, name, slug }` or null if not found.
   - On error, return null (do NOT throw).

3. `getFederalCollectionId(): Promise<number>`
   - Query `collections` table WHERE `slug = 'federal-civics'`, return the `id`.
   - Cache the result in a module-level variable (it never changes).
   - On error, return 1 as hardcoded fallback (the seed script creates Federal as ID 1).

**Difficulty selection algorithm:**
- Query ALL available questions for the collection (excluding recent + expired).
- Group by difficulty: easy[], medium[], hard[].
- Target distribution: Q1=easy, Q10=hard, Q2-Q9 = ~3 easy + ~3 medium + ~2 hard (shuffled).
- Implementation:
  1. Pick 1 random easy question for Q1 (remove from easy pool).
  2. Pick 1 random hard question for Q10 (remove from hard pool).
  3. For Q2-Q9, pick 3 from easy pool, 3 from medium pool, 2 from hard pool (all random within each difficulty). Shuffle these 8 questions randomly.
  4. Combine: [Q1_easy, ...shuffled_middle_8, Q10_hard].
- **Constraint relaxation:** If any difficulty pool doesn't have enough questions:
  - First try to fill from the other pools (prefer medium, then the other).
  - If still not enough total questions, fill with whatever is available.
  - NEVER allow duplicates. NEVER error out — always return as many unique questions as possible (up to 10).
  - If fewer than 10 total questions available, return what you have (the game can handle shorter sessions via its existing answer counting).
  - Log a warning: `console.warn('Relaxed difficulty constraints: only ${available} questions available for collection ${collectionId}')`.

**JSON fallback function (private):**
- `loadQuestionsFromJSON(): Question[]`
- Use `readFileSync` + `JSON.parse` to load `../data/questions.json` (same pattern currently in game.ts).
- Shuffle with Fisher-Yates and return first 10.
- This is the emergency fallback — no difficulty ordering, no collection filtering.

**Data transformation function (private):**
- `transformDBQuestions(dbRows: DBRow[], topicMap: Map<number, string>): Question[]`
- Map each DB row to the existing `Question` interface:
  - `id` = `row.externalId` (NOT `row.id` — critical for backward compat)
  - `text` = `row.text`
  - `options` = `row.options` (already string[] in JSONB)
  - `correctAnswer` = `row.correctAnswer`
  - `explanation` = `row.explanation`
  - `difficulty` = `row.difficulty`
  - `topic` = `topicMap.get(row.topicId) || 'Unknown'`
  - `topicCategory` = `row.subcategory || ''`
  - `learningContent` = if row.learningContent is not null, transform to: `{ topic: topicMap.get(row.topicId) || 'Unknown', paragraphs: row.learningContent.paragraphs, corrections: row.learningContent.corrections, source: row.source }`

**Topic map loading (private):**
- `loadTopicMap(): Promise<Map<number, string>>`
- Query all topics: `db.select({ id: topics.id, name: topics.name }).from(topics)`
- Return Map<number, string> mapping topic ID to display name.
- Cache in module-level variable (topics rarely change).

**Recent question tracking:**
- This service does NOT manage the tracking storage itself — it receives `recentQuestionIds: string[]` as a parameter.
- Plan 02 will handle the in-memory tracking map in the game route.

**Import guidance:**
- Use `import { db } from '../db/index.js'`
- Use `import { questions, collections, collectionQuestions, topics } from '../db/schema.js'`
- Use `import { eq, and, notInArray, isNull, or, gt, sql } from 'drizzle-orm'`
- Use `import { readFileSync } from 'fs'` and `import { fileURLToPath } from 'url'` for JSON fallback
- Import `Question` type from `'../services/sessionService.js'` (re-export or import directly)

**Anti-patterns to avoid:**
- Do NOT use a class — use exported functions (matches progressionService pattern).
- Do NOT expose database errors to callers — always catch and fallback/return null.
- Do NOT use `questions.id` (database serial) as the question ID — always use `questions.externalId`.
- Do NOT import from drizzle-orm/node-postgres — the db instance is already created in db/index.ts.
  </action>
  <verify>
Run `npx tsc --noEmit` from `backend/` directory to verify the file compiles with no TypeScript errors. Verify the file exports `selectQuestionsForGame`, `getCollectionMetadata`, and `getFederalCollectionId` by checking the file content.
  </verify>
  <done>
`questionService.ts` exists with all three exported functions, compiles without errors, and follows the existing service module pattern. The difficulty selection algorithm handles constraint relaxation. JSON fallback is implemented. Data transformation maps DB rows to the existing Question interface using externalId as id.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes in backend/ directory
- `questionService.ts` exports `selectQuestionsForGame`, `getCollectionMetadata`, `getFederalCollectionId`
- File uses Drizzle ORM imports from `drizzle-orm` (eq, and, notInArray, etc.)
- File imports `db` from `../db/index.js` and schema from `../db/schema.js`
- File contains JSON fallback via readFileSync of `questions.json`
- File transforms `externalId` to `id` (NOT database serial id)
- File contains difficulty selection: easy for Q1, hard for Q10, balanced mix for Q2-Q9
- File contains constraint relaxation logic with console.warn
</verification>

<success_criteria>
QuestionService module compiles, exports the three public functions, implements difficulty-balanced selection with constraint relaxation, transforms DB rows to match the existing Question interface, and falls back silently to JSON on any database error.
</success_criteria>

<output>
After completion, create `.planning/phases/14-question-service-route-integration/14-01-SUMMARY.md`
</output>
