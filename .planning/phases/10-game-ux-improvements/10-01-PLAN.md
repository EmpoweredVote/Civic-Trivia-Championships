---
phase: 10-game-ux-improvements
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/features/game/gameReducer.ts
  - frontend/src/features/game/hooks/useGameState.ts
  - frontend/src/features/game/components/ScorePopup.tsx
  - frontend/src/types/game.ts
autonomous: true

must_haves:
  truths:
    - "SELECT_ANSWER for Q1-Q9 transitions directly to 'locked' phase with timer paused"
    - "SELECT_ANSWER for Q10 transitions to 'selected' phase (two-step preserved)"
    - "LOCK_ANSWER action only used for Q10 confirmation"
    - "Suspense pause is 750ms, auto-advance is 4000ms, question preview is 1000ms"
    - "Question timer is 20s (was 25s), final question timer unchanged at 50s"
    - "ScorePopup duration is 1500ms (was 2000ms)"
  artifacts:
    - path: "frontend/src/features/game/gameReducer.ts"
      provides: "Single-click state transitions with Q10 exception"
      contains: "currentQuestionIndex === 9"
    - path: "frontend/src/features/game/hooks/useGameState.ts"
      provides: "Updated timing constants and single-click selectAnswer flow"
      contains: "SUSPENSE_PAUSE_MS = 750"
    - path: "frontend/src/features/game/components/ScorePopup.tsx"
      provides: "Faster score popup animation"
      contains: "1500"
  key_links:
    - from: "gameReducer.ts SELECT_ANSWER"
      to: "useGameState.ts selectAnswer"
      via: "dispatch + async lockAnswer logic"
      pattern: "phase.*locked.*isTimerPaused.*true"
    - from: "useGameState.ts SUSPENSE_PAUSE_MS"
      to: "lockAnswer Promise.all"
      via: "setTimeout in Promise.all"
      pattern: "SUSPENSE_PAUSE_MS"
---

<objective>
Refactor the game state machine for single-click answer selection and update all timing constants for snappier pacing.

Purpose: This is the foundation for Phase 10 -- the state machine and timing changes must land first because the UI components (Plan 02) depend on these phase transitions and timing values.

Output: Modified gameReducer.ts with single-click transitions (Q10 exception), updated useGameState.ts with new timing and selectAnswer flow, faster ScorePopup duration.
</objective>

<execution_context>
@C:\Users\Chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-game-ux-improvements/10-CONTEXT.md
@.planning/phases/10-game-ux-improvements/10-RESEARCH.md

# Source files being modified
@frontend/src/features/game/gameReducer.ts
@frontend/src/features/game/hooks/useGameState.ts
@frontend/src/features/game/components/ScorePopup.tsx
@frontend/src/types/game.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor gameReducer for single-click answer selection</name>
  <files>
    frontend/src/features/game/gameReducer.ts
    frontend/src/types/game.ts
  </files>
  <action>
Modify the `SELECT_ANSWER` case in gameReducer.ts to implement single-click answering for Q1-Q9, while preserving two-step lock-in for Q10:

**gameReducer.ts changes:**

1. `SELECT_ANSWER` case: Change the guard from `phase !== 'answering' && phase !== 'selected'` to `phase !== 'answering'` (no longer valid in 'selected' for Q1-Q9). Then add Q10 branching:
   - If `state.currentQuestionIndex === 9`: return `{ ...state, phase: 'selected', selectedOption: action.optionIndex }` (existing two-step behavior)
   - Otherwise: return `{ ...state, phase: 'locked', selectedOption: action.optionIndex, isTimerPaused: true }` (immediate lock-in)

2. `LOCK_ANSWER` case: Add a comment that this is now Q10-only. Keep existing logic unchanged (guard: `phase !== 'selected'`).

3. `TIMEOUT` case: Update guard -- since Q1-Q9 no longer have 'selected' phase, timeout should only fire from 'answering'. BUT Q10 still has 'selected' phase. Keep `phase !== 'answering' && phase !== 'selected'` guard unchanged (still correct for Q10 edge case where user selected but didn't lock in before timeout).

4. `PAUSE_GAME` case: Same situation -- keep `phase !== 'answering' && phase !== 'selected'` guard unchanged (Q10 may still be in 'selected' phase).

5. In the `REVEAL_ANSWER` responseTime calculation (line 110), update the hardcoded `25` to `20` to match the new question timer: `responseTime: (state.currentQuestionIndex === 9 ? 50 : 20) - action.timeRemaining`. Same for `TIMEOUT` case (line 143).

**types/game.ts:** The `GamePhase` type keeps 'selected' in the union (still used by Q10). Add a comment: `| 'selected' // Player highlighted answer, awaiting lock-in (Q10 only for standard questions)`

Do NOT remove the 'selected' phase from GamePhase -- it is still used by Q10 wager question.
Do NOT modify the SELECT_ANSWER guard to allow re-selection in 'selected' phase for Q10 -- the existing behavior where Q10 can change selection before lock-in should be preserved. Add this back: for Q10, also allow selection during 'selected' phase. So the full guard becomes: `if (state.phase !== 'answering' && !(state.phase === 'selected' && state.currentQuestionIndex === 9)) return state;`
  </action>
  <verify>
Run `cd "C:/Project Test/frontend" && npx tsc --noEmit` -- should compile with zero errors. Grep for 'currentQuestionIndex === 9' in gameReducer.ts to confirm Q10 branching exists.
  </verify>
  <done>
SELECT_ANSWER for Q1-Q9 transitions directly to 'locked' with timer paused. SELECT_ANSWER for Q10 transitions to 'selected' (preserving two-step). LOCK_ANSWER is Q10-only. responseTime uses 20 instead of 25. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update timing constants and useGameState selectAnswer flow</name>
  <files>
    frontend/src/features/game/hooks/useGameState.ts
    frontend/src/features/game/components/ScorePopup.tsx
  </files>
  <action>
**useGameState.ts changes:**

1. Update timing constants at top of file:
   - `SUSPENSE_PAUSE_MS = 750` (was 1500)
   - `AUTO_ADVANCE_MS = 4000` (was 6000)
   - Keep `ANNOUNCEMENT_DURATION_MS = 2500` unchanged
   - Keep `WAGER_SUSPENSE_MS = 1500` unchanged

2. Refactor `selectAnswer` function: Since Q1-Q9 now go directly to 'locked' in the reducer, the hook needs to handle the server submission immediately after dispatch. Change selectAnswer from a simple dispatch to an async function that:
   - Dispatches `SELECT_ANSWER` (which for Q1-Q9 now sets phase to 'locked' and pauses timer)
   - For Q1-Q9 (currentQuestionIndex !== 9): immediately runs the same server submission + suspense logic that lockAnswer currently does. Extract the shared submission logic into a private helper `submitAndReveal(timeRemaining: number)` to avoid duplication.
   - For Q10: just dispatches (existing lockAnswer path still works for Q10)

3. The `selectAnswer` function signature changes: it needs `timeRemaining` as a parameter now (for Q1-Q9 to submit immediately). Update: `selectAnswer: (optionIndex: number, timeRemaining?: number) => void`. For Q10, timeRemaining is not needed at selection time (it's captured at lock-in).

4. Extract common server submission logic from `lockAnswer` into a private async function:
   ```typescript
   const submitAndReveal = async (timeRemaining: number) => {
     if (!sessionIdRef.current) return;
     // Clear any existing suspense timeout
     if (suspenseTimeoutRef.current) {
       clearTimeout(suspenseTimeoutRef.current);
     }
     const currentQ = state.questions[state.currentQuestionIndex];
     if (!currentQ) return;
     const wager = state.currentQuestionIndex === 9 ? state.wagerAmount : undefined;
     try {
       const [serverResponse] = await Promise.all([
         submitAnswer(sessionIdRef.current, currentQ.id, state.selectedOption, timeRemaining, wager),
         new Promise(resolve => setTimeout(resolve, SUSPENSE_PAUSE_MS)),
       ]);
       dispatch({ type: 'REVEAL_ANSWER', timeRemaining, scoreData: { ... } });
     } catch (error) {
       // existing fallback logic
     }
   };
   ```

5. Update `selectAnswer`:
   ```typescript
   const selectAnswer = (optionIndex: number, timeRemaining?: number) => {
     dispatch({ type: 'SELECT_ANSWER', optionIndex });
     // For Q1-Q9, immediately submit (reducer already set phase to 'locked')
     if (state.currentQuestionIndex !== 9 && timeRemaining !== undefined) {
       submitAndReveal(timeRemaining);
     }
   };
   ```

6. Update `lockAnswer` to call `submitAndReveal` instead of duplicating logic. lockAnswer is now Q10-only: `const lockAnswer = async (timeRemaining: number) => { if (state.phase !== 'selected' || !sessionIdRef.current) return; dispatch({ type: 'LOCK_ANSWER' }); await submitAndReveal(timeRemaining); };`

7. Update the `UseGameStateReturn` interface: `selectAnswer: (optionIndex: number, timeRemaining?: number) => void;`

IMPORTANT: The `submitAndReveal` helper reads `state.selectedOption`, but after dispatch, the React state hasn't updated yet within the same call. Instead, pass `optionIndex` directly to submitAndReveal as a parameter and use it for the server call instead of reading from state. Update submitAndReveal signature: `submitAndReveal(optionIndex: number, timeRemaining: number)`.

**ScorePopup.tsx changes:**

1. Change the auto-complete timeout from `2000` to `1500`: `setTimeout(() => { onComplete(); }, 1500);`

Do NOT change ANNOUNCEMENT_DURATION_MS or WAGER_SUSPENSE_MS -- those are unrelated to this phase's pacing changes.
Do NOT move timing constants to a shared file -- keep them co-located where they're used.
  </action>
  <verify>
Run `cd "C:/Project Test/frontend" && npx tsc --noEmit` -- should compile with zero errors. Grep useGameState.ts for `SUSPENSE_PAUSE_MS = 750` and `AUTO_ADVANCE_MS = 4000`. Grep ScorePopup.tsx for `1500`.
  </verify>
  <done>
Timing constants updated: 750ms suspense, 4000ms auto-advance. selectAnswer handles immediate server submission for Q1-Q9. lockAnswer is Q10-only. ScorePopup duration is 1500ms. All code compiles cleanly. No regressions in wager flow.
  </done>
</task>

</tasks>

<verification>
1. `cd "C:/Project Test/frontend" && npx tsc --noEmit` -- zero TypeScript errors
2. `cd "C:/Project Test/frontend" && npm run build` -- production build succeeds
3. Grep gameReducer.ts for `currentQuestionIndex === 9` -- Q10 branching present
4. Grep useGameState.ts for timing values: `750`, `4000`, `1000`
5. Grep ScorePopup.tsx for `1500` -- reduced popup duration
</verification>

<success_criteria>
- State machine correctly routes Q1-Q9 directly to 'locked' phase on answer selection
- Q10 preserves two-step select -> lock-in flow
- All 5 timing constants updated (preview 1s, suspense 0.75s, auto-advance 4s, timer 20s, popup 1.5s)
- TypeScript compiles with zero errors
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/10-game-ux-improvements/10-01-SUMMARY.md`
</output>
