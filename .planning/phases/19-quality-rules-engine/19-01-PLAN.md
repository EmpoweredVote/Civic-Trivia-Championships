---
phase: 19-quality-rules-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/services/qualityRules/types.ts
  - backend/src/services/qualityRules/rules/ambiguity.ts
  - backend/src/services/qualityRules/rules/lookup.ts
  - backend/src/services/qualityRules/rules/structural.ts
  - backend/src/services/qualityRules/rules/partisan.ts
  - backend/src/services/qualityRules/scoring.ts
  - backend/src/services/qualityRules/index.ts
autonomous: true

must_haves:
  truths:
    - "Running quality rules against any question returns a score 0-100 and a list of violations with severity"
    - "Ambiguous answers and vague qualifiers are detected as blocking violations"
    - "Pure lookup facts (obscure, no civic utility) are detected as blocking violations"
    - "Broken Learn More links are detected as blocking violations"
    - "Weak explanations and short questions are detected as advisory violations"
    - "Partisan framing keywords are detected as advisory violations"
  artifacts:
    - path: "backend/src/services/qualityRules/types.ts"
      provides: "Violation, RuleResult, AuditResult, QualityRule types"
      exports: ["Severity", "Violation", "RuleResult", "AuditResult", "QualityRule"]
    - path: "backend/src/services/qualityRules/rules/ambiguity.ts"
      provides: "Answer overlap and vague qualifier detection"
      exports: ["checkAmbiguousAnswers", "checkVagueQualifiers"]
    - path: "backend/src/services/qualityRules/rules/lookup.ts"
      provides: "Pure lookup vs foundational knowledge detection"
      exports: ["checkPureLookup"]
    - path: "backend/src/services/qualityRules/rules/structural.ts"
      provides: "Question length, explanation quality, Learn More URL validation"
      exports: ["checkStructuralQuality", "checkLearnMoreLink"]
    - path: "backend/src/services/qualityRules/rules/partisan.ts"
      provides: "Partisan framing keyword detection"
      exports: ["checkPartisanFraming"]
    - path: "backend/src/services/qualityRules/scoring.ts"
      provides: "Weighted score calculation from violations"
      exports: ["calculateQualityScore"]
    - path: "backend/src/services/qualityRules/index.ts"
      provides: "Main audit runner that orchestrates all rules"
      exports: ["auditQuestion", "auditQuestions", "ALL_RULES"]
  key_links:
    - from: "backend/src/services/qualityRules/index.ts"
      to: "backend/src/services/qualityRules/rules/*.ts"
      via: "imports all rule functions"
      pattern: "import.*from.*rules/"
    - from: "backend/src/services/qualityRules/index.ts"
      to: "backend/src/services/qualityRules/scoring.ts"
      via: "calls calculateQualityScore with violations"
      pattern: "calculateQualityScore"
    - from: "backend/src/services/qualityRules/types.ts"
      to: "backend/src/db/schema.ts"
      via: "QuestionInput type mirrors Question schema shape"
      pattern: "QuestionInput"
---

<objective>
Build the complete quality rules engine as composable, pure TypeScript functions that evaluate civic trivia questions against codified quality standards. Each rule returns structured violations with severity (blocking vs advisory), and a scoring function aggregates violations into a 0-100 quality score.

Purpose: This is the foundation for QUAL-01 and QUAL-02. Every subsequent plan in this phase depends on these rule functions. The engine must also be reusable for Phase 21's generation pipeline gating.
Output: A `services/qualityRules/` directory with types, 4 rule modules, scoring, and an audit runner.
</objective>

<execution_context>
@C:\Users\Chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-quality-rules-engine/19-CONTEXT.md
@.planning/phases/19-quality-rules-engine/19-RESEARCH.md
@backend/src/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create types and all quality rule functions</name>
  <files>
    backend/src/services/qualityRules/types.ts
    backend/src/services/qualityRules/rules/ambiguity.ts
    backend/src/services/qualityRules/rules/lookup.ts
    backend/src/services/qualityRules/rules/structural.ts
    backend/src/services/qualityRules/rules/partisan.ts
  </files>
  <action>
    Create `backend/src/services/qualityRules/types.ts`:
    - `Severity` type: `'blocking' | 'advisory'`
    - `Violation` interface: `{ rule: string; severity: Severity; message: string; evidence?: string }`
    - `RuleResult` interface: `{ passed: boolean; violations: Violation[] }`
    - `QualityRule` type: function that takes a QuestionInput and returns `RuleResult | Promise<RuleResult>`
    - `QuestionInput` interface: mirrors the Question type from schema.ts but only the fields rules need: `{ text: string; options: string[]; correctAnswer: number; explanation: string; difficulty: string; source: { name: string; url: string }; externalId: string }`
    - `AuditResult` interface: `{ question: QuestionInput; violations: Violation[]; score: number; hasBlockingViolations: boolean; hasAdvisoryOnly: boolean }`

    Create `backend/src/services/qualityRules/rules/ambiguity.ts`:
    - `checkAmbiguousAnswers`: Blocking rule. Computes word overlap (Jaccard similarity) between all pairs of answer options. If any pair exceeds 0.7 overlap, flag as blocking. Exclude common civic stop words from similarity calculation (e.g., "the", "a", "of", "and", "in", "to", "is", "for", "that", "federal", "state", "local", "government", "national"). This prevents false positives from shared civic vocabulary.
    - `checkVagueQualifiers`: Blocking rule. Scans question text (case-insensitive) for vague qualifiers: "best", "most important", "primarily", "generally", "typically", "mainly". These create ambiguity because multiple answers could be defensible. Evidence field should include the found qualifiers.

    Create `backend/src/services/qualityRules/rules/lookup.ts`:
    - `checkPureLookup`: Blocking rule. Detects questions that test obscure memorization with no civic utility. The test is NOT about format (numbers/dates are fine). The test is: "Would knowing this make me a more interesting, civically engaged person?"
    - Implementation approach: Build two lists:
      1. FOUNDATIONAL_PATTERNS (allowlist): regex patterns for foundational civic knowledge that should PASS even if they look like lookup. Examples: /how many.*(senator|representative|council|justice|member)/i, /who is.*(president|governor|mayor|speaker)/i, /what does.*(congress|senate|court|council|amendment)/i, /what is the.*(constitution|bill of rights|amendment)/i
      2. OBSCURE_INDICATORS (blocklist): patterns for obscure trivia. Examples: /what year was.*(act|law|statute|bill).*(passed|enacted|signed)/i, /in what year/i combined with no foundational pattern match, /what date/i combined with no foundational pattern match, /who was the \d+(st|nd|rd|th)/i (e.g., "who was the 14th Secretary of...")
    - Logic: If any FOUNDATIONAL_PATTERN matches, PASS (never flag foundational knowledge). Else if any OBSCURE_INDICATOR matches, flag as blocking with evidence showing the matched pattern.
    - Keep this conservative -- better to miss some bad questions than flag good ones. This can be tuned after the dry-run audit.

    Create `backend/src/services/qualityRules/rules/structural.ts`:
    - `checkStructuralQuality`: Advisory rule. Checks:
      1. Question text length: flag if < 20 chars (too terse) or > 500 chars (too verbose). Advisory severity.
      2. Explanation length: flag if < 30 chars (too brief to be educational). Advisory severity.
      3. Explanation should cite a source: flag if explanation does not contain any citation indicator (check for patterns like "According to", "Source:", "per the", the source.name value, or a URL). Advisory severity.
      4. All 4 options present and non-empty. Advisory severity.
    - `checkLearnMoreLink`: Blocking rule. Async function. Uses the `link-check` npm package to validate source.url. Wrap in Promise with 5-second timeout. Treat HTTP 404, 500, and connection failures as blocking. Treat timeouts as advisory (government sites can be slow). Use `Promise.resolve()` wrapper pattern so it works in `Promise.all()`.
    - IMPORTANT: Install `link-check` package first: `npm install link-check` in the backend directory. Also install its types if available, otherwise create a minimal type declaration.

    Create `backend/src/services/qualityRules/rules/partisan.ts`:
    - `checkPartisanFraming`: Advisory rule (not blocking -- per CONTEXT.md this needs refinement). Scans question text AND explanation for high-confidence partisan keywords/phrases. Start with overtly partisan terms:
      - Left-leaning bias: "radical left", "socialist agenda", "liberal elite", "nanny state", "gun-grabbing"
      - Right-leaning bias: "far right", "extremist", "freedom-hating", "anti-American", "woke"
      - Loaded framing: "scheme", "plot", "threat to democracy", "destroying", "ruining"
    - Case-insensitive matching. Evidence field shows matched terms.
    - Document in a comment that this rule is intentionally conservative (high-confidence only) and may be upgraded to LLM-based detection in Phase 21.
  </action>
  <verify>
    Run `npx tsc --noEmit` from backend directory -- all new files compile without errors.
    Manually inspect that each rule file exports the expected function(s).
  </verify>
  <done>
    All 5 files exist with proper TypeScript types. Each rule function is a pure function (or async for URL check) that accepts QuestionInput and returns RuleResult. Ambiguity and vague qualifiers are blocking. Structural quality (except broken links) is advisory. Partisan framing is advisory. Pure lookup flags obscure facts as blocking while allowing foundational civic knowledge.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create scoring module and audit runner</name>
  <files>
    backend/src/services/qualityRules/scoring.ts
    backend/src/services/qualityRules/index.ts
  </files>
  <action>
    Create `backend/src/services/qualityRules/scoring.ts`:
    - Export `SCORE_WEIGHTS` object mapping rule IDs to point deductions:
      - 'ambiguous-answers': 40 (worst offense per CONTEXT.md)
      - 'vague-qualifiers': 30
      - 'pure-lookup': 25
      - 'partisan-framing': 15
      - 'broken-learn-more': 40 (blocking)
      - 'learn-more-timeout': 5 (advisory -- might just be slow)
      - 'weak-explanation': 10
      - 'short-question': 5
      - 'long-question': 5
      - 'missing-citation': 8
      - 'missing-options': 10
    - Export `calculateQualityScore(violations: Violation[]): number` -- starts at 100, subtracts weight for each violation, floors at 0. Default penalty of 10 for unknown rule IDs.
    - IMPORTANT: Score is informational only. Do NOT use score for blocking decisions. Only `hasBlockingViolations` determines archival.

    Create `backend/src/services/qualityRules/index.ts`:
    - Import all rule functions from `./rules/` files.
    - Export `ALL_SYNC_RULES` array: [checkAmbiguousAnswers, checkVagueQualifiers, checkPureLookup, checkStructuralQuality, checkPartisanFraming]
    - Export `ALL_ASYNC_RULES` array: [checkLearnMoreLink]
    - Export `auditQuestion(question: QuestionInput, options?: { skipUrlCheck?: boolean }): Promise<AuditResult>`:
      1. Run all sync rules directly (they're fast, pure functions)
      2. If `skipUrlCheck` is not true, run async rules via Promise.all()
      3. Flatten all violations
      4. Calculate score via `calculateQualityScore()`
      5. Set `hasBlockingViolations` = any violation with severity 'blocking'
      6. Set `hasAdvisoryOnly` = has violations but none blocking
      7. Return AuditResult
    - Export `auditQuestions(questions: QuestionInput[], options?: { skipUrlCheck?: boolean; concurrency?: number }): Promise<AuditResult[]>`:
      1. Map over questions calling auditQuestion()
      2. Use Promise.all() for parallel execution
      3. If concurrency specified, batch into chunks of that size (to avoid hammering URLs)
      4. Default concurrency: 10 for URL checks, unlimited for sync-only
    - The `skipUrlCheck` option exists so the dry-run audit can be run quickly without network calls, and URL validation can be a separate pass.
  </action>
  <verify>
    Run `npx tsc --noEmit` from backend directory -- all files compile.
    Verify that `index.ts` imports from all 4 rule files and scoring.ts.
    Verify that `auditQuestion` returns an AuditResult with score, violations, and blocking flags.
  </verify>
  <done>
    The scoring module assigns weighted penalties per rule ID and calculates a 0-100 score. The audit runner orchestrates all rules (sync + async), aggregates violations, calculates score, and flags blocking status. Both single-question and batch audit functions are exported. The `skipUrlCheck` option allows fast sync-only audits.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes in backend directory with zero errors
2. All 7 files exist under `backend/src/services/qualityRules/`
3. `link-check` package is installed in backend/package.json
4. Each rule function is exported and callable with a QuestionInput
5. `auditQuestion()` returns a complete AuditResult with score, violations, and blocking flags
</verification>

<success_criteria>
- Quality rules engine compiles and exports all functions
- Blocking rules: ambiguous answers, vague qualifiers, pure lookup, broken learn-more links
- Advisory rules: structural quality (length, explanation, citation), partisan framing, learn-more timeouts
- Score calculation: 0-100 weighted, informational only (not used for blocking decisions)
- Audit runner: single + batch question audit with optional URL check skip
- All code is pure functions (no DB access, no side effects) except URL validation
</success_criteria>

<output>
After completion, create `.planning/phases/19-quality-rules-engine/19-01-SUMMARY.md`
</output>
