---
phase: 19-quality-rules-engine
plan: 03
type: execute
wave: 3
depends_on: ["19-02"]
files_modified:
  - backend/src/scripts/archive-violations.ts
  - backend/src/routes/game.ts
autonomous: false

must_haves:
  truths:
    - "Questions with blocking violations are archived (status = 'archived') and no longer appear in gameplay"
    - "Collections with fewer than 50 active questions are hidden from the collection picker"
    - "Collections with 50+ active questions remain visible and playable"
    - "Archived questions still exist in the database and can be restored"
    - "The archive script reports exactly what it changed"
  artifacts:
    - path: "backend/src/scripts/archive-violations.ts"
      provides: "Script that archives questions with blocking violations and reports collection health"
      contains: "archived"
    - path: "backend/src/routes/game.ts"
      provides: "Updated collection picker with 50-question minimum threshold"
      contains: "MIN_QUESTION_THRESHOLD"
  key_links:
    - from: "backend/src/scripts/archive-violations.ts"
      to: "backend/src/services/qualityRules/index.ts"
      via: "runs audit to identify blocking violations"
      pattern: "import.*auditQuestion.*qualityRules"
    - from: "backend/src/scripts/archive-violations.ts"
      to: "backend/src/db/schema.ts"
      via: "updates question status to archived"
      pattern: "status.*archived"
    - from: "backend/src/routes/game.ts"
      to: "backend/src/db/schema.ts"
      via: "filters collections by active question count >= 50"
      pattern: "MIN_QUESTION_THRESHOLD.*50"
---

<objective>
Archive questions that fail blocking quality rules and update the collection picker to enforce a 50-question minimum. After archival, verify that all collections remain playable or are properly hidden.

Purpose: This delivers QUAL-04 (remove/archive blocking failures) and the collection safety threshold from CONTEXT.md. Players will only see quality-verified content. Collections that drop below 50 questions disappear from the picker (auto-re-enable when replenished in Phase 21).
Output: Archive script, updated collection picker threshold, and verified gameplay integrity.
</objective>

<execution_context>
@C:\Users\Chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-quality-rules-engine/19-CONTEXT.md
@.planning/phases/19-quality-rules-engine/19-01-SUMMARY.md
@.planning/phases/19-quality-rules-engine/19-02-SUMMARY.md
@backend/src/routes/game.ts
@backend/src/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Archive blocking violations and update collection threshold</name>
  <files>
    backend/src/scripts/archive-violations.ts
    backend/src/routes/game.ts
  </files>
  <action>
    Create `backend/src/scripts/archive-violations.ts`:
    - Import `'../env.js'` first
    - Import `db` from `'../db/index.js'`
    - Import `questions, collections, collectionQuestions` from `'../db/schema.js'`
    - Import `auditQuestion` from `'../services/qualityRules/index.js'`
    - Import `eq, sql, and, inArray` from `'drizzle-orm'`

    Main function `archiveViolations()`:
    1. Accept optional CLI flag `--dry-run` that reports what WOULD be archived without making changes.

    2. Fetch all active questions (same query pattern as audit script).

    3. Run `auditQuestion()` on each with `skipUrlCheck: false` (do full validation including URLs). Process in batches of 10 for URL checks.

    4. Identify questions with blocking violations.

    5. Console output - Pre-archival summary:
       ```
       === ARCHIVE BLOCKING VIOLATIONS ===

       Questions with blocking violations: XX
       Questions to archive: [list externalIds]

       Per-collection impact:
       Collection Name          | Current | To Remove | After | Status
       Federal Civics           |     100 |         5 |    95 | OK (>= 50)
       Denver Metro             |      80 |         3 |    77 | OK (>= 50)
       [Collection X]           |      55 |        10 |    45 | HIDDEN (< 50)
       ```

    6. If NOT dry-run mode:
       a. Archive questions: Update status to 'archived' for all blocking-violation questions.
          ```typescript
          const idsToArchive = blockingResults.map(r => r.question.externalId);
          await db.update(questions)
            .set({
              status: 'archived',
              updatedAt: sql`NOW()`
            })
            .where(inArray(questions.externalId, idsToArchive));
          ```
       b. Also save quality scores for ALL audited questions (not just archived ones):
          ```typescript
          for (const result of allResults) {
            await db.update(questions)
              .set({ qualityScore: result.score })
              .where(eq(questions.externalId, result.question.externalId));
          }
          ```
       c. Log: "Archived XX questions. Quality scores saved for YYY questions."

    7. Post-archival verification:
       - Query active question counts per collection
       - Report which collections are now below 50 threshold
       - Report which collections are still healthy
       ```
       === POST-ARCHIVAL VERIFICATION ===

       Collection Name          | Active Questions | Status
       Federal Civics           |               95 | VISIBLE (>= 50)
       Denver Metro             |               77 | VISIBLE (>= 50)
       [Collection X]           |               45 | HIDDEN (< 50) -- will reappear when count >= 50
       ```

    8. Exit with `process.exit(0)`.

    Add npm script to `backend/package.json`:
    ```json
    "archive-violations": "tsx src/scripts/archive-violations.ts"
    ```

    Update `backend/src/routes/game.ts`:
    - Change `MIN_QUESTION_THRESHOLD` from 10 to 50.
    - Update the collection query to count ONLY active questions (add `eq(questions.status, 'active')` to the join/where condition if not already present).
    - The existing query at line 67-77 already filters `eq(collections.isActive, true)` and joins with questions. Ensure the count only includes questions where `status = 'active'` (not expired/archived). Check the existing WHERE clause -- it filters by `questions.status = 'active'` at line 71, which is good. Just update the threshold constant.
    - This means: when active question count drops below 50, the collection disappears from the picker. When Phase 21 adds replacements and count crosses 50+, it automatically reappears. No flag to manage -- it's a computed filter.

    Run the archive script:
    ```bash
    cd backend && npx tsx src/scripts/archive-violations.ts
    ```
  </action>
  <verify>
    Run `npx tsc --noEmit` -- all files compile.
    Run `npx tsx src/scripts/archive-violations.ts --dry-run` first to preview impact.
    Then run without `--dry-run` to apply archival.
    Verify archived questions have `status = 'archived'` in the database.
    Verify `GET /collections` endpoint returns only collections with 50+ active questions.
    Verify gameplay still works: start a game session and confirm only active questions appear.
  </verify>
  <done>
    Questions with blocking violations are archived. Quality scores are persisted for all questions. The collection picker uses a 50-question threshold. Collections below 50 active questions are hidden. The archive script reported what changed and post-archival collection health.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete quality rules engine, audit, and archival pipeline:
    1. Quality rules service with blocking/advisory severity
    2. Dry-run audit report (markdown file at backend/audit-report.md)
    3. Archived questions with blocking violations
    4. Collection picker now requires 50+ active questions
  </what-built>
  <how-to-verify>
    1. Review `backend/audit-report.md` -- check that flagged questions look correct (ambiguous, pure lookup, etc.) and that good questions are NOT flagged
    2. Check the console output from the archive script -- verify collection health looks reasonable
    3. Visit the live app collection picker -- all collections should still appear (unless one genuinely dropped below 50)
    4. Start a game session -- verify it works normally with active questions only
    5. If any questions were incorrectly archived, they can be restored by setting status back to 'active'
  </how-to-verify>
  <resume-signal>Type "approved" if the audit results and archival look correct, or describe any issues (false positives, missing collections, gameplay problems)</resume-signal>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes in backend directory
2. Questions with blocking violations have `status = 'archived'` in the database
3. All questions have `quality_score` populated
4. `GET /api/game/collections` returns only collections with 50+ active questions
5. Starting a game session returns only active (non-archived) questions
6. `backend/audit-report.md` exists with full audit details
7. No collection dropped below its minimum viable count unexpectedly
</verification>

<success_criteria>
- Blocking-violation questions are archived via soft delete (status = 'archived')
- Quality scores saved for ALL questions (not just archived ones)
- Collection picker threshold raised from 10 to 50
- Collections with < 50 active questions are hidden from picker
- Gameplay unaffected -- only serves active questions (already filtered by status)
- Archive script is reusable with --dry-run flag
- User has verified audit results and gameplay integrity
</success_criteria>

<output>
After completion, create `.planning/phases/19-quality-rules-engine/19-03-SUMMARY.md`
</output>
