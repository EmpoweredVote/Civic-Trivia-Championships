---
phase: 16-expiration-system
plan: 02
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - backend/src/routes/health.ts
  - backend/src/routes/admin.ts
  - backend/src/server.ts
autonomous: true

must_haves:
  truths:
    - "Health endpoint returns per-collection counts (active, expiring-soon, expired, archived) and tier labels"
    - "Health endpoint returns system-wide summary with totals across all collections"
    - "Admin endpoint lists expired and expiring-soon questions with question text, collection, and expiry date"
    - "Admin endpoint supports renew (new expires_at), and archive actions on expired questions"
    - "Admin endpoints require authentication (401 if no valid token)"
    - "Renewed questions immediately return to 'active' status and appear in game rotation"
  artifacts:
    - path: "backend/src/routes/health.ts"
      provides: "GET /health/collections endpoint with per-collection health data"
      contains: "collections.*activeCount|expiringSoonCount|tier"
    - path: "backend/src/routes/admin.ts"
      provides: "Auth-protected admin CRUD for expired question management"
      exports: ["router"]
    - path: "backend/src/server.ts"
      provides: "Admin route registration at /api/admin"
      contains: "adminRouter"
  key_links:
    - from: "backend/src/routes/health.ts"
      to: "backend/src/db/schema.ts"
      via: "drizzle aggregation query on questions.status and questions.expiresAt"
      pattern: "questions\\.status|COUNT"
    - from: "backend/src/routes/admin.ts"
      to: "backend/src/middleware/auth.ts"
      via: "authenticateToken middleware on all admin routes"
      pattern: "authenticateToken"
    - from: "backend/src/routes/admin.ts"
      to: "backend/src/db/schema.ts"
      via: "drizzle update on questions.status, questions.expiresAt, questions.expirationHistory"
      pattern: "questions\\.status|questions\\.expiresAt|questions\\.expirationHistory"
---

<objective>
Add the collection health endpoint and admin API routes for managing expired questions.

Purpose: The health endpoint (ADM-01) gives visibility into per-collection question counts and health tiers so content reviewers know which collections need attention. The admin routes (EXP-03) enable the three review actions (renew, update+renew, archive) that complete the expiration lifecycle.

Output: GET /health/collections returns per-collection health with tier labels. GET/POST /api/admin/questions endpoints enable listing and acting on expired/expiring-soon questions behind auth.
</objective>

<execution_context>
@C:\Users\Chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-expiration-system/16-CONTEXT.md
@.planning/phases/16-expiration-system/16-RESEARCH.md
@.planning/phases/16-expiration-system/16-01-SUMMARY.md

Key existing files:
@backend/src/db/schema.ts
@backend/src/routes/health.ts
@backend/src/middleware/auth.ts
@backend/src/server.ts
@backend/src/routes/game.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Collection health endpoint</name>
  <files>backend/src/routes/health.ts</files>
  <action>
  Add a new route `GET /collections` to `backend/src/routes/health.ts` (the existing `/health` mount means the full path is `GET /health/collections`). This follows the existing public `/health` pattern -- no auth required.

  The endpoint must return a JSON response with this shape:

  ```typescript
  {
    summary: {
      totalCollections: number,
      totalActive: number,
      totalExpiringSoon: number,
      totalExpired: number,
      totalArchived: number
    },
    collections: Array<{
      id: number,
      name: string,
      slug: string,
      activeCount: number,
      expiringSoonCount: number,
      expiredCount: number,
      archivedCount: number,
      tier: 'Healthy' | 'At Risk' | 'Critical',
      isPlayable: boolean
    }>
  }
  ```

  Implementation details:
  - Import `db` from `'../db/index.js'` and `collections, collectionQuestions, questions` from `'../db/schema.js'`
  - Import `eq, sql` from `'drizzle-orm'`
  - Compute `now = new Date()` and `soonThreshold = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000)`
  - Use a single SQL aggregation query that JOINs collections -> collection_questions -> questions and uses COUNT with FILTER clauses:
    - **active**: `status = 'active'` AND (`expires_at IS NULL` OR `expires_at > soonThreshold`)
    - **expiringSoon**: `status = 'active'` AND `expires_at > now` AND `expires_at <= soonThreshold`
    - **expired**: `status = 'expired'`
    - **archived**: `status = 'archived'`
  - GROUP BY collection id, name, slug
  - For each collection, compute tier:
    - `activeCount >= 20` (2x minimum of 10) = 'Healthy'
    - `activeCount >= 10` AND `activeCount < 20` = 'At Risk'
    - `activeCount < 10` = 'Critical'
  - `isPlayable = activeCount >= 10`
  - Compute summary by summing across all collections
  - Query ONLY active collections (`is_active = true`)
  - Wrap in try/catch, return 500 on error

  Keep the existing `GET /` route completely unchanged. Add the new route AFTER the existing one.
  </action>
  <verify>
  - `cd backend && npx tsc --noEmit` compiles without errors
  - `curl http://localhost:3000/health/collections` returns JSON with summary and collections array (requires running server)
  - Response includes Federal Civics collection with activeCount=120, tier='Healthy', isPlayable=true
  </verify>
  <done>GET /health/collections returns per-collection health data with four count buckets and computed tier labels. System-wide summary included. Public endpoint (no auth).</done>
</task>

<task type="auto">
  <name>Task 2: Admin API routes for expired question management</name>
  <files>backend/src/routes/admin.ts, backend/src/server.ts</files>
  <action>
  1. Create `backend/src/routes/admin.ts` with auth-protected routes:

  Import `Router, Request, Response` from express, `authenticateToken` from `'../middleware/auth.js'`, `db` from `'../db/index.js'`, `questions, collections, collectionQuestions` from `'../db/schema.js'`, and `eq, and, or, lte, gt, isNotNull, sql, inArray` from `'drizzle-orm'`.

  Create router and apply `router.use(authenticateToken)` to protect ALL admin routes.

  **GET /questions** - List expired and expiring-soon questions:
  - Accept optional query params: `status` ('expired' | 'expiring-soon' | 'archived', default: show all non-active), `collectionId` (number, optional filter)
  - For 'expiring-soon': query WHERE `status = 'active'` AND `expires_at > now` AND `expires_at <= now + 30 days`
  - For 'expired': query WHERE `status = 'expired'`
  - For 'archived': query WHERE `status = 'archived'`
  - Default (no status param): return both expired AND expiring-soon (union of the two queries above)
  - JOIN with collection_questions and collections to include collection name(s) per question
  - Return array of objects: `{ id, externalId, text, difficulty, expiresAt, status, collectionNames: string[], expirationHistory }`
  - Order by `expires_at ASC` (soonest first)

  **POST /questions/:id/renew** - Renew an expired question:
  - Accept body: `{ expiresAt: string }` (ISO 8601 date string)
  - Validate: `expiresAt` must be a valid future date
  - Find question by `id` param (this is the database serial `id`, NOT externalId)
  - Update: set `status = 'active'`, set `expires_at` to new date, append to `expirationHistory`: `{ action: 'renewed', timestamp: now, previousExpiresAt: old value, newExpiresAt: new value }`
  - Use SQL for JSONB append: `sql\`${questions.expirationHistory} || ${JSON.stringify([historyEntry])}::jsonb\``
  - Return updated question
  - Return 404 if question not found, 400 if invalid date

  **POST /questions/:id/archive** - Permanently retire a question:
  - Find question by `id` param (database serial id)
  - Update: set `status = 'archived'`, append to `expirationHistory`: `{ action: 'archived', timestamp: now }`
  - Return updated question
  - Return 404 if question not found

  Export `{ router }`.

  2. In `backend/src/server.ts`:
  - Add import: `import { router as adminRouter } from './routes/admin.js';`
  - Add route mount AFTER the profile routes line: `app.use('/api/admin', adminRouter);`

  IMPORTANT: All .js extensions in imports (ESM). The `:id` param in routes refers to the database serial `questions.id` (integer), not the `externalId` string.
  </action>
  <verify>
  - `cd backend && npx tsc --noEmit` compiles without errors
  - `curl http://localhost:3000/api/admin/questions` returns 401 (no auth token) â€” confirms auth middleware works
  - Server starts without errors and logs show admin route mounted
  </verify>
  <done>Admin API provides GET /api/admin/questions (list expired/expiring-soon), POST /api/admin/questions/:id/renew, and POST /api/admin/questions/:id/archive. All routes auth-protected. Renewal immediately reactivates questions.</done>
</task>

</tasks>

<verification>
- GET /health/collections returns per-collection health with tier labels and isPlayable flag
- Health response includes summary with totals across all collections
- GET /api/admin/questions returns 401 without auth, returns question list with auth
- POST /api/admin/questions/:id/renew updates status to 'active' and sets new expires_at
- POST /api/admin/questions/:id/archive updates status to 'archived'
- Both admin actions append to expirationHistory audit trail
- TypeScript compiles cleanly: `cd backend && npx tsc --noEmit`
</verification>

<success_criteria>
- ADM-01 satisfied: Health endpoint reports per-collection question counts, expiring-soon counts, expired counts, and tier labels
- EXP-03 fully satisfied: Expired questions flagged for content review via database status + admin listing
- EXP-01 supported: Renewal action immediately reactivates expired questions (status back to 'active')
</success_criteria>

<output>
After completion, create `.planning/phases/16-expiration-system/16-02-SUMMARY.md`
</output>
