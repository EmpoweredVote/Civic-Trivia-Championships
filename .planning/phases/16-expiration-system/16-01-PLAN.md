---
phase: 16-expiration-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/db/schema.ts
  - backend/package.json
  - backend/src/cron/expirationSweep.ts
  - backend/src/cron/startCron.ts
  - backend/src/server.ts
  - backend/src/services/questionService.ts
  - backend/src/routes/game.ts
autonomous: true

must_haves:
  truths:
    - "Expired questions are flagged with status 'expired' in the database after cron runs"
    - "Expiring-soon questions (within 30 days) are identified and logged as 'needs_attention'"
    - "Cron job runs hourly and logs structured JSON output for each sweep"
    - "Questions without expires_at remain status 'active' (permanent content)"
    - "Questions with status != 'active' never appear in new game sessions"
    - "Collection picker question counts exclude non-active questions"
  artifacts:
    - path: "backend/src/db/schema.ts"
      provides: "status and expirationHistory fields on questions table"
      contains: "status.*text|expirationHistory.*jsonb"
    - path: "backend/src/cron/expirationSweep.ts"
      provides: "Sweep logic that finds expired/expiring-soon questions and updates status"
      exports: ["runExpirationSweep"]
    - path: "backend/src/cron/startCron.ts"
      provides: "Cron scheduler registration"
      exports: ["startExpirationCron"]
    - path: "backend/src/services/questionService.ts"
      provides: "Question selection filtered by status='active'"
      contains: "eq.*questions\\.status.*active"
  key_links:
    - from: "backend/src/server.ts"
      to: "backend/src/cron/startCron.ts"
      via: "import and call startExpirationCron() during server startup"
      pattern: "startExpirationCron"
    - from: "backend/src/cron/expirationSweep.ts"
      to: "backend/src/db/schema.ts"
      via: "drizzle query using questions.status and questions.expiresAt"
      pattern: "questions\\.status|questions\\.expiresAt"
    - from: "backend/src/services/questionService.ts"
      to: "backend/src/db/schema.ts"
      via: "WHERE clause includes eq(questions.status, 'active')"
      pattern: "eq\\(questions\\.status"
---

<objective>
Add expiration infrastructure: schema fields for question status tracking and audit history, update query layer to filter by status, plus an hourly cron sweep that automatically flags expired questions and logs expiring-soon questions.

Purpose: This is the foundation of the expiration system. The status field enables queryable state (active/expired/archived), the expirationHistory JSONB field tracks renewal audit trails, and the cron job automates the sweep so expired content drops from rotation without manual intervention. Critically, the query layer must also filter on status so that expired/archived questions never appear in new games (EXP-01).

Output: Updated schema with new fields pushed to database, question queries filtering by status='active', node-cron installed, hourly sweep running on server startup with structured JSON logging.
</objective>

<execution_context>
@C:\Users\Chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-expiration-system/16-CONTEXT.md
@.planning/phases/16-expiration-system/16-RESEARCH.md

Key existing files:
@backend/src/db/schema.ts
@backend/src/server.ts
@backend/package.json
@backend/drizzle.config.ts
@backend/src/services/questionService.ts
@backend/src/routes/game.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema migration + node-cron install + query layer status filter</name>
  <files>backend/src/db/schema.ts, backend/package.json, backend/src/services/questionService.ts, backend/src/routes/game.ts</files>
  <action>
  1. Install node-cron: `cd backend && npm install --save node-cron` (no @types needed - v4 ships ESM with built-in types)

  2. Add two new fields to the `questions` table in `backend/src/db/schema.ts`:

  ```typescript
  status: text('status').notNull().default('active'), // 'active' | 'expired' | 'archived'
  expirationHistory: jsonb('expiration_history').$type<Array<{
    action: 'expired' | 'renewed' | 'archived';
    timestamp: string; // ISO 8601
    previousExpiresAt?: string;
    newExpiresAt?: string;
  }>>().default([]),
  ```

  Add `status` AFTER the `expiresAt` field (line 74) and `expirationHistory` after `status`. Keep the existing field order intact.

  3. Add an index for the status field (inside the table's index function, after the existing `expiresAtIdx`):

  ```typescript
  statusIdx: index('idx_questions_status').on(table.status)
  ```

  4. Run `cd backend && npx drizzle-kit push` to push schema changes to the database. This uses the existing drizzle.config.ts which points to the civic_trivia schema.

  IMPORTANT: The `status` field defaults to 'active', so all existing 120 questions will automatically get status='active' without data migration. The `expirationHistory` defaults to empty array `[]`.

  Do NOT modify any existing field definitions or indexes. Only add the new fields and index.

  5. Update `backend/src/services/questionService.ts` to filter by status='active':

  In the `selectQuestionsForGame()` function (around line 293), update the `baseConditions` to include a status check. The current code is:

  ```typescript
  const baseConditions = and(
    eq(collectionQuestions.collectionId, targetCollectionId),
    or(
      isNull(questions.expiresAt),
      gt(questions.expiresAt, now)
    )
  );
  ```

  Change it to:

  ```typescript
  const baseConditions = and(
    eq(collectionQuestions.collectionId, targetCollectionId),
    eq(questions.status, 'active'),
    or(
      isNull(questions.expiresAt),
      gt(questions.expiresAt, now)
    )
  );
  ```

  Also add `eq` to the existing drizzle-orm imports if not already present (it IS already imported on line 11).

  6. Update `backend/src/routes/game.ts` GET /collections endpoint to filter by status='active':

  In the collections query (around line 64-68), the current raw SQL WHERE clause is:

  ```sql
  ${collections.isActive} = true
  AND (${questions.id} IS NULL
    OR ${questions.expiresAt} IS NULL
    OR ${questions.expiresAt} > ${now})
  ```

  Update it to also check status:

  ```sql
  ${collections.isActive} = true
  AND (${questions.id} IS NULL
    OR (${questions.status} = 'active'
      AND (${questions.expiresAt} IS NULL
        OR ${questions.expiresAt} > ${now})))
  ```

  This ensures the collection picker question counts only include active (non-expired, non-archived) questions. Import `questions` from schema is already present on line 8.
  </action>
  <verify>
  - `cd backend && npx drizzle-kit push` completes without errors
  - `cd backend && npx tsx -e "import { db } from './src/db/index.js'; import { questions } from './src/db/schema.js'; const r = await db.select({ status: questions.status, history: questions.expirationHistory }).from(questions).limit(1); console.log(r); process.exit(0);"` returns a row with status='active' and history=[]
  - `cd backend && npx tsc --noEmit` compiles without errors (confirms questionService.ts and game.ts changes are valid)
  </verify>
  <done>Questions table has `status` (text, default 'active') and `expiration_history` (jsonb, default []) columns. All existing questions have status='active'. Index exists on status column. Both questionService.ts and game.ts filter by status='active', ensuring expired/archived questions never appear in new games or collection counts.</done>
</task>

<task type="auto">
  <name>Task 2: Hourly cron sweep implementation</name>
  <files>backend/src/cron/expirationSweep.ts, backend/src/cron/startCron.ts, backend/src/server.ts</files>
  <action>
  1. Create `backend/src/cron/expirationSweep.ts` with the main sweep logic:

  Export an async function `runExpirationSweep()` that:
  - Queries questions WHERE `expires_at <= now` AND `status = 'active'` (newly expired only, not already-expired)
  - For each newly expired question: update `status` to 'expired', append `{ action: 'expired', timestamp: now.toISOString(), previousExpiresAt: question.expiresAt.toISOString() }` to the `expirationHistory` JSONB array using `sql` template: `sql\`${questions.expirationHistory} || ${JSON.stringify([historyEntry])}::jsonb\``
  - Queries questions WHERE `expires_at > now` AND `expires_at <= now + 30 days` AND `status = 'active'` (expiring-soon)
  - Logs each expired question as structured JSON (level: 'warn', job: 'expiration-sweep', questionId, expiresAt)
  - Logs each expiring-soon question as structured JSON (level: 'info', job: 'expiration-sweep', message: 'Question expiring soon', questionId, expiresAt, daysUntilExpiry)
  - Logs sweep summary (level: 'info', job: 'expiration-sweep', newlyExpiredCount, expiringSoonCount, durationMs)
  - Wraps everything in try/catch, logs errors as level: 'error'
  - Uses `isNotNull(questions.expiresAt)` in all queries to match the partial index

  Use imports from drizzle-orm: `eq, and, lte, gt, isNotNull, sql`
  Use imports from schema: `questions`
  Use import from db: `db`

  2. Create `backend/src/cron/startCron.ts`:

  ```typescript
  import cron from 'node-cron';
  import { runExpirationSweep } from './expirationSweep.js';

  export function startExpirationCron(): void {
    // Run at minute 0 of every hour
    cron.schedule('0 * * * *', async () => {
      await runExpirationSweep();
    });

    console.log('Expiration cron job registered (runs hourly at :00)');
  }
  ```

  3. In `backend/src/server.ts`, add cron startup:
  - Add import: `import { startExpirationCron } from './cron/startCron.js';`
  - Call `startExpirationCron()` inside `startServer()` AFTER `initializeSessionManager()` and BEFORE middleware setup (around line 28). This ensures the database connection is ready before cron registers.

  IMPORTANT: Use ESM imports (all .js extensions). The project uses `"type": "module"` in package.json.
  </action>
  <verify>
  - `cd backend && npx tsc --noEmit` compiles without errors
  - `cd backend && npx tsx -e "import { runExpirationSweep } from './src/cron/expirationSweep.js'; await runExpirationSweep(); process.exit(0);"` runs sweep manually and logs JSON output (should show 0 newly expired since no questions have expires_at set)
  - Server starts successfully: `cd backend && timeout 5 npx tsx src/server.ts 2>&1 || true` shows "Expiration cron job registered" in output
  </verify>
  <done>Cron sweep runs hourly, finds newly expired questions, updates their status to 'expired', appends to audit history, logs expiring-soon questions, and outputs structured JSON logs. Server registers cron on startup.</done>
</task>

</tasks>

<verification>
- Schema has `status` and `expiration_history` fields on questions table
- All 120 existing questions have status='active' and empty expiration history
- node-cron is in backend/package.json dependencies
- `questionService.ts` selectQuestionsForGame() includes `eq(questions.status, 'active')` in WHERE clause
- `game.ts` GET /collections query includes `questions.status = 'active'` in WHERE clause
- `backend/src/cron/expirationSweep.ts` exports `runExpirationSweep`
- `backend/src/cron/startCron.ts` exports `startExpirationCron`
- `backend/src/server.ts` imports and calls `startExpirationCron()`
- TypeScript compiles cleanly: `cd backend && npx tsc --noEmit`
- Manual sweep run produces structured JSON logs
</verification>

<success_criteria>
- EXP-01 satisfied: Questions with status != 'active' are excluded from game selection AND collection counts
- EXP-02 satisfied: Hourly cron schedule registered with node-cron at '0 * * * *'
- EXP-03 partially satisfied: Expired questions logged with structured output and status updated to 'expired' in database (dual surfacing)
- Schema ready for health endpoint (Plan 02) and admin routes (Plan 02)
</success_criteria>

<output>
After completion, create `.planning/phases/16-expiration-system/16-01-SUMMARY.md`
</output>
