---
phase: 02-game-core
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - frontend/src/features/game/gameReducer.ts
  - frontend/src/features/game/hooks/useGameState.ts
  - frontend/src/features/game/hooks/useKeyPress.ts
autonomous: true

must_haves:
  truths:
    - "Game state machine transitions correctly through all phases: idle -> starting -> answering -> selected -> locked -> revealing -> answering (next) -> complete"
    - "Timeout triggers reveal with null selected answer"
    - "Keyboard shortcuts A/B/C/D select answers only during answering/selected phases"
    - "Lock-in triggers 1.5s suspense pause before reveal"
    - "Auto-advance triggers after reveal with configurable delay"
  artifacts:
    - path: "frontend/src/features/game/gameReducer.ts"
      provides: "Pure game state reducer function with all transitions"
      exports: ["gameReducer", "initialGameState"]
      min_lines: 60
    - path: "frontend/src/features/game/hooks/useGameState.ts"
      provides: "Hook wrapping useReducer with action dispatchers"
      exports: ["useGameState"]
      min_lines: 40
    - path: "frontend/src/features/game/hooks/useKeyPress.ts"
      provides: "Keyboard shortcut hook with cleanup and input exclusion"
      exports: ["useKeyPress"]
      min_lines: 20
  key_links:
    - from: "frontend/src/features/game/hooks/useGameState.ts"
      to: "frontend/src/features/game/gameReducer.ts"
      via: "useReducer(gameReducer, initialGameState)"
      pattern: "useReducer.*gameReducer"
    - from: "frontend/src/features/game/hooks/useGameState.ts"
      to: "frontend/src/types/game.ts"
      via: "imports GameState, GameAction types"
      pattern: "import.*game\\.ts|import.*types/game"
---

<objective>
Build the game state machine using useReducer and custom hooks. This is the brain of the game — all state transitions (start, answer, lock, reveal, next, timeout, complete) are modeled as a pure reducer with a custom hook wrapper. Also create the keyboard shortcut hook.

Purpose: The state machine drives all game behavior. UI components (Plan 03) will consume this hook to render and interact with the game. Separating logic from UI keeps both clean and testable.
Output: gameReducer.ts, useGameState.ts, useKeyPress.ts
</objective>

<execution_context>
@C:\Users\Chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-game-core/02-CONTEXT.md
@.planning/phases/02-game-core/02-RESEARCH.md
@frontend/src/types/game.ts (created in Plan 01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement game state reducer</name>
  <files>
    frontend/src/features/game/gameReducer.ts
  </files>
  <action>
    Create `frontend/src/features/game/gameReducer.ts` implementing the game state machine.

    **State shape** (import GameState from types/game.ts):
    ```typescript
    const initialGameState: GameState = {
      phase: 'idle',
      questions: [],
      currentQuestionIndex: 0,
      selectedOption: null,
      answers: [],
      isTimerPaused: false
    };
    ```

    **Action types** (define GameAction union type here or in types/game.ts):
    - `START_GAME { questions: Question[] }` — sets questions, moves to 'answering', resets index to 0
    - `SELECT_ANSWER { optionIndex: number }` — sets selectedOption, moves to 'selected' (only valid in 'answering' or 'selected' phase)
    - `LOCK_ANSWER` — moves to 'locked', pauses timer (only valid in 'selected' phase when selectedOption is not null)
    - `REVEAL_ANSWER` — moves to 'revealing', records answer in answers array (compares selectedOption to correctAnswer). Works from 'locked' phase.
    - `TIMEOUT` — moves to 'revealing' with selectedOption = null, records as incorrect. Works from 'answering' or 'selected' phase.
    - `NEXT_QUESTION` — if currentQuestionIndex < 9: increments index, resets selectedOption to null, moves to 'answering', unpauses timer. If index >= 9: moves to 'complete'.
    - `QUIT_GAME` — moves to 'idle', resets everything

    **Reducer rules:**
    - Pure function — no side effects, no setTimeout inside reducer
    - Always return new state object (never mutate)
    - Invalid state+action combinations return current state unchanged
    - When recording an answer in REVEAL_ANSWER/TIMEOUT, push to answers array:
      ```typescript
      { questionId: currentQuestion.id, selectedOption: state.selectedOption, correct: state.selectedOption === currentQuestion.correctAnswer, timeRemaining: 0 }
      ```
      (timeRemaining will be set by the hook, not the reducer — pass it via action payload)

    Actually, adjust: REVEAL_ANSWER and TIMEOUT should accept `timeRemaining: number` in their action payload so the answer record captures it.

    Export `gameReducer` and `initialGameState`.
  </action>
  <verify>
    Run `cd frontend && npx tsc --noEmit` to verify the reducer compiles with correct types.
    Manually trace state transitions:
    - idle -> START_GAME -> answering
    - answering -> SELECT_ANSWER -> selected
    - selected -> SELECT_ANSWER (change) -> selected (different option)
    - selected -> LOCK_ANSWER -> locked
    - locked -> REVEAL_ANSWER -> revealing
    - revealing -> NEXT_QUESTION -> answering (if < 10) or complete (if 10)
    - answering -> TIMEOUT -> revealing
  </verify>
  <done>
    Pure game reducer handles all state transitions. Invalid actions are ignored. State is never mutated. All game phases connected correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useGameState and useKeyPress hooks</name>
  <files>
    frontend/src/features/game/hooks/useGameState.ts
    frontend/src/features/game/hooks/useKeyPress.ts
  </files>
  <action>
    1. Create `frontend/src/features/game/hooks/useKeyPress.ts`:
       - Custom hook: `useKeyPress(key: string, callback: () => void, enabled: boolean)`
       - Adds keydown event listener on window when enabled
       - Ignores events when target is INPUT or TEXTAREA element
       - Compares `event.key.toLowerCase()` to key parameter
       - Calls `event.preventDefault()` then `callback()` on match
       - Returns cleanup function to remove listener
       - Dependencies: [key, callback, enabled]
       - Export the hook

    2. Create `frontend/src/features/game/hooks/useGameState.ts`:
       - Wraps `useReducer(gameReducer, initialGameState)` from gameReducer.ts
       - Imports `fetchQuestions` from `../../../services/gameService`
       - Provides these action dispatchers:

       **startGame():**
       - Calls `fetchQuestions()` to get 10 questions from API
       - Dispatches `START_GAME` with the questions
       - Handles fetch errors gracefully (console.error, stay in idle)

       **selectAnswer(optionIndex: number):**
       - Dispatches `SELECT_ANSWER { optionIndex }`

       **lockAnswer(timeRemaining: number):**
       - Only dispatches `LOCK_ANSWER` if state.phase is 'selected'
       - After dispatch, sets a 1500ms setTimeout to dispatch `REVEAL_ANSWER { timeRemaining }`
       - Store timeout ref to clean up on unmount
       - The suspense pause duration (1500ms) should be a named constant: `SUSPENSE_PAUSE_MS = 1500`

       **handleTimeout():**
       - Dispatches `TIMEOUT { timeRemaining: 0 }`
       - After dispatch, does NOT auto-advance (reveal stays until NEXT_QUESTION)

       **nextQuestion():**
       - Dispatches `NEXT_QUESTION`

       **quitGame():**
       - Dispatches `QUIT_GAME`

       **Auto-advance logic:**
       - When state.phase changes to 'revealing', start a timer (e.g., 3000ms) for auto-advance
       - When auto-advance fires, dispatch `NEXT_QUESTION`
       - If user clicks "Next" button before timer fires, cancel the auto-advance timer
       - Use useEffect watching state.phase to manage this
       - Auto-advance delay should be a named constant: `AUTO_ADVANCE_MS = 4000`

       **Cleanup:**
       - useEffect cleanup for both suspense pause and auto-advance timeouts on unmount

       **Return value:**
       ```typescript
       return {
         state, // GameState
         currentQuestion, // derived: questions[currentQuestionIndex] or null
         startGame,
         selectAnswer,
         lockAnswer,
         handleTimeout,
         nextQuestion,
         quitGame,
         gameResult // derived: { answers, totalCorrect, totalQuestions } when phase is 'complete'
       }
       ```
  </action>
  <verify>
    Run `cd frontend && npx tsc --noEmit` to verify hooks compile.
    Verify the hooks directory structure exists: `frontend/src/features/game/hooks/`
    Check that useGameState imports from gameReducer correctly.
    Check that useKeyPress has proper cleanup (return () => window.removeEventListener).
  </verify>
  <done>
    useGameState hook provides complete game lifecycle management with start, select, lock, reveal timing, auto-advance, and cleanup. useKeyPress hook handles keyboard shortcuts with proper cleanup and input exclusion.
  </done>
</task>

</tasks>

<verification>
- `cd frontend && npx tsc --noEmit` passes
- gameReducer.ts exports gameReducer and initialGameState
- useGameState.ts exports useGameState hook
- useKeyPress.ts exports useKeyPress hook
- No circular dependencies between files
- All timeouts have cleanup functions
</verification>

<success_criteria>
- Game state machine correctly handles all phase transitions
- useGameState hook manages game lifecycle with async question fetch
- Suspense pause (1.5s) fires after lock-in before reveal
- Auto-advance (4s) fires after reveal
- useKeyPress hook handles keyboard shortcuts with cleanup
- All TypeScript types check successfully
</success_criteria>

<output>
After completion, create `.planning/phases/02-game-core/02-02-SUMMARY.md`
</output>
