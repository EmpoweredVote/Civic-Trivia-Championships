---
phase: 05-progression-profile
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/schema.sql
  - backend/src/models/User.ts
  - backend/src/services/progressionService.ts
  - backend/src/services/sessionService.ts
  - backend/src/routes/game.ts
  - backend/src/middleware/auth.ts
autonomous: true

must_haves:
  truths:
    - "XP earned per game completion (50 base + 1 per correct)"
    - "Gems earned per game completion (10 base + 1 per correct)"
    - "Progression updates persist to user profile in database"
    - "Anonymous users play without progression (no errors)"
  artifacts:
    - path: "backend/schema.sql"
      provides: "Users table with progression columns"
      contains: "total_xp"
    - path: "backend/src/services/progressionService.ts"
      provides: "XP/gems calculation and atomic DB updates"
      exports: ["calculateProgression", "updateUserStats"]
    - path: "backend/src/routes/game.ts"
      provides: "Game endpoints wired with optional auth and progression"
      contains: "progression"
  key_links:
    - from: "backend/src/routes/game.ts"
      to: "backend/src/services/progressionService.ts"
      via: "import and call in results endpoint"
      pattern: "updateUserStats|calculateProgression"
    - from: "backend/src/routes/game.ts"
      to: "backend/src/middleware/auth.ts"
      via: "optional auth middleware on session creation"
      pattern: "optionalAuth|req\\.user"
---

<objective>
Add database schema for user progression, create the progression service for XP/gems calculation and atomic stats updates, and wire game completion to persist progression for authenticated users.

Purpose: This is the backend foundation for Phase 5. All subsequent plans (results screen rewards, profile page) depend on the progression data flowing from game completion through to the database.

Output: Working backend where completing a game as an authenticated user calculates XP/gems, updates user stats atomically in PostgreSQL, and returns progression data in the results API response. Anonymous users continue to work without progression.
</objective>

<execution_context>
@C:\Users\Chris\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Chris\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:\Project Test\.planning\PROJECT.md
@C:\Project Test\.planning\ROADMAP.md
@C:\Project Test\.planning\STATE.md
@C:\Project Test\.planning\phases\05-progression-profile\05-CONTEXT.md
@C:\Project Test\.planning\phases\05-progression-profile\05-RESEARCH.md

Key existing files:
@C:\Project Test\backend\schema.sql
@C:\Project Test\backend\src\models\User.ts
@C:\Project Test\backend\src\services\sessionService.ts
@C:\Project Test\backend\src\routes\game.ts
@C:\Project Test\backend\src\middleware\auth.ts
@C:\Project Test\backend\src\config\database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database schema migration and User model update</name>
  <files>
    backend/schema.sql
    backend/src/models/User.ts
  </files>
  <action>
    1. Update `backend/schema.sql` to add progression columns to the users table:
       ```sql
       ALTER TABLE users
         ADD COLUMN IF NOT EXISTS total_xp INTEGER DEFAULT 0 NOT NULL,
         ADD COLUMN IF NOT EXISTS total_gems INTEGER DEFAULT 0 NOT NULL,
         ADD COLUMN IF NOT EXISTS games_played INTEGER DEFAULT 0 NOT NULL,
         ADD COLUMN IF NOT EXISTS best_score INTEGER DEFAULT 0 NOT NULL,
         ADD COLUMN IF NOT EXISTS total_correct INTEGER DEFAULT 0 NOT NULL,
         ADD COLUMN IF NOT EXISTS total_questions INTEGER DEFAULT 0 NOT NULL,
         ADD COLUMN IF NOT EXISTS avatar_url VARCHAR(500);
       ```
       Add CHECK constraints for non-negative values on total_xp, total_gems, games_played.
       Add indexes on total_xp DESC and best_score DESC (for future leaderboard queries).
       Keep the existing CREATE TABLE and triggers intact - add the ALTER TABLE block below them.

    2. Run the schema migration against the development database:
       ```bash
       cd backend && psql $DATABASE_URL -f schema.sql
       ```
       If DATABASE_URL isn't set, check `backend/.env` or `backend/src/env.ts` for connection details and construct the URL.

    3. Update `backend/src/models/User.ts`:
       - Add the new fields to the `User` interface: totalXp, totalGems, gamesPlayed, bestScore, totalCorrect, totalQuestions, avatarUrl
       - Update `findById` query to SELECT the new columns with proper camelCase aliases (total_xp as "totalXp", etc.)
       - Add a new `getProfileStats(id: number)` method that returns only the stats fields (totalXp, totalGems, gamesPlayed, bestScore, totalCorrect, totalQuestions, avatarUrl)
       - Add an `updateStats` method that performs the atomic increment update:
         ```sql
         UPDATE users SET
           total_xp = total_xp + $1,
           total_gems = total_gems + $2,
           games_played = games_played + 1,
           best_score = GREATEST(best_score, $3),
           total_correct = total_correct + $4,
           total_questions = total_questions + $5
         WHERE id = $6
         ```
         Use a transaction (BEGIN/COMMIT/ROLLBACK) with proper try/catch/finally and client.release().
       - Add an `updateAvatarUrl(id: number, avatarUrl: string)` method for future avatar upload use.
  </action>
  <verify>
    Run `psql $DATABASE_URL -c "SELECT column_name FROM information_schema.columns WHERE table_name='users' ORDER BY ordinal_position;"` and confirm total_xp, total_gems, games_played, best_score, total_correct, total_questions, avatar_url columns exist.
    Run `npx tsx backend/src/models/User.ts` (or a quick test script) to confirm the file compiles without TypeScript errors.
  </verify>
  <done>
    Users table has 7 new columns with defaults, constraints, and indexes. User model has getProfileStats and updateStats methods using atomic increments in a transaction.
  </done>
</task>

<task type="auto">
  <name>Task 2: Progression service and game route wiring</name>
  <files>
    backend/src/services/progressionService.ts
    backend/src/routes/game.ts
    backend/src/middleware/auth.ts
    backend/src/services/sessionService.ts
  </files>
  <action>
    1. Create `backend/src/services/progressionService.ts`:
       - Export `calculateProgression(correctAnswers: number, totalQuestions: number): { xpEarned: number, gemsEarned: number }`
         - XP formula: 50 + correctAnswers
         - Gems formula: 10 + correctAnswers
       - Export `updateUserProgression(userId: number, score: number, correctAnswers: number, totalQuestions: number): Promise<{ xpEarned: number, gemsEarned: number }>`
         - Calls calculateProgression to get rewards
         - Calls User.updateStats with the calculated values
         - Returns the progression rewards

    2. Add an `optionalAuth` middleware to `backend/src/middleware/auth.ts`:
       - Same logic as `authenticateToken` but does NOT return 401 on missing/invalid token
       - If valid token: sets req.user (same as authenticateToken)
       - If no token or invalid token: sets req.user = undefined and calls next()
       - This allows game endpoints to work for both authenticated and anonymous users

    3. Update `backend/src/services/sessionService.ts`:
       - Change `createSession` to accept `userId: string | number` (number for authenticated users, 'anonymous' for unauthenticated)
       - Update the `GameSession` interface userId type to `string | number`

    4. Wire progression into `backend/src/routes/game.ts`:
       - Import `optionalAuth` middleware and `updateUserProgression` from progressionService
       - Apply `optionalAuth` middleware to POST /session endpoint
       - In POST /session: extract userId from `req.user?.userId` if authenticated, otherwise use 'anonymous'. Pass to sessionManager.createSession.
       - Store userId on the session so it's available at results time.
       - Update GET /results/:sessionId endpoint:
         - After getting results from sessionManager.getResults(), check if the session has an authenticated userId (not 'anonymous')
         - If authenticated: call updateUserProgression(userId, totalScore, totalCorrect, totalQuestions)
         - Add `progression: { xpEarned, gemsEarned } | null` to the response (null for anonymous)
         - IMPORTANT: Only call updateUserProgression ONCE per session. Add a `progressionAwarded` boolean flag to GameSession. Check it before awarding and set it to true after. This prevents double-awarding if results endpoint is called multiple times.
  </action>
  <verify>
    1. Start the backend server: `cd backend && npm run dev`
    2. Test anonymous game flow (no auth header):
       ```bash
       curl -X POST http://localhost:3000/api/game/session
       ```
       Should return 201 with sessionId and questions (no errors).
    3. Test authenticated game flow:
       - Login to get an access token
       - Create session with Authorization header
       - Submit 10 answers
       - GET /results/:sessionId - response should include `progression: { xpEarned: number, gemsEarned: number }`
    4. Verify TypeScript compiles: `cd backend && npx tsc --noEmit`
  </verify>
  <done>
    Game completion for authenticated users calculates and persists XP/gems. Results endpoint returns progression data (or null for anonymous). Progression is only awarded once per session. Anonymous users experience no change in behavior.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `cd backend && npx tsc --noEmit`
2. Anonymous game flow works identically to before (no regression)
3. Authenticated game flow returns progression in results response
4. Database shows updated stats after authenticated game completion:
   `psql $DATABASE_URL -c "SELECT total_xp, total_gems, games_played, best_score FROM users WHERE id = <test_user_id>;"`
5. Calling GET /results twice for the same session returns same progression values (no double-awarding)
</verification>

<success_criteria>
- XP earned = 50 + correctAnswers for authenticated users
- Gems earned = 10 + correctAnswers for authenticated users
- Stats updated atomically in database (total_xp, total_gems, games_played, best_score, total_correct, total_questions)
- best_score uses GREATEST (keeps maximum, not incrementing)
- Anonymous users get null progression, no database errors
- No regression in existing game flow
</success_criteria>

<output>
After completion, create `.planning/phases/05-progression-profile/05-01-SUMMARY.md`
</output>
